{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Polygon ID Polygon ID allows to create private identity infrastructures: Issuers can attest any type of identity related information by issuing claims Users hold claims in their wallet and portably use them to privately authenticate across platforms Web2 and Web3 platforms can set up customized requirements (query) to provide users with private access rights Polygon ID and Iden3 Iden3 is the open-source protocol at the basis of Polygon ID. The protocol defines on a low-level how the parties listed above communicate and interact with each other. Polygon ID is an abstraction layer to enable developers build applications leveraging Iden3 protocol. START HERE Polygon ID on GitHub","title":"Home"},{"location":"#polygon-id","text":"Polygon ID allows to create private identity infrastructures: Issuers can attest any type of identity related information by issuing claims Users hold claims in their wallet and portably use them to privately authenticate across platforms Web2 and Web3 platforms can set up customized requirements (query) to provide users with private access rights","title":"Polygon ID"},{"location":"#polygon-id-and-iden3","text":"Iden3 is the open-source protocol at the basis of Polygon ID. The protocol defines on a low-level how the parties listed above communicate and interact with each other. Polygon ID is an abstraction layer to enable developers build applications leveraging Iden3 protocol.","title":"Polygon ID and Iden3"},{"location":"#start-here","text":"","title":"START HERE"},{"location":"#polygon-id-on-github","text":"","title":"Polygon ID on GitHub"},{"location":"circuits/main-circuits/","text":"Main Circuits This iden3 circuits are the heart of the protocol. The main ones are: stateTransition.circom , checks the execution of the identity state transtion by taking the old identity state and the new identity state as inputs. authentication.circom , checks that the prover is owner of an identity. credentialAtomicQueryMTP.circom , checks that a claim issued to the prover (and added to issuer's Claims Tree) satisfies a query set by the verifier. credentialAtomicQuerySig.circom checks that a claim issued to the prover (and signed by the Issuer) satisfies a query set by the verifier. You can find all the source code on Github - Iden3 Circuits and here are the details of the Iden3 Protocol Phase2 Trusted Setup Ceremony stateTransition Github Example of instantiation Instantiation Parameters nLevels Merkle tree depth level for Claims tree Inputs Input Description Public or Private userID Prover's Identifier Public oldUserState Prover's Identity State (before transition) Public newUserState Prover's Identity State (after transition) Public isOldStateGenesis \"1\" indicates that the old state is genesis: it means that this is the first State Transition, otherwise \"0\" Public claimsTreeRoot Prover's Claims Tree Root Private authClaimMtp[nLevels] Merkle Tree Proof of Auth Claim inside Prover's Claims tree Private authClaim[8] Prover's Auth Claim Private revTreeRoot Prover's Revocation Tree Root Private authClaimNonRevMtp[nLevels] Merkle Tree Proof of non membership of Auth Claim inside Prover's Revocation Tree Private authClaimNonRevMtpNoAux Flag that indicates whether to check the auxiliary Node Private authClaimNonRevMtpAuxHv Auxiliary Node Value Private authClaimNonRevMtpAuxHi Auxiliary Node Index Private rootsTreeRoot Prover's Roots Tree Root Private signatureR8x Signature of the challenge (Rx point) Private signatureR8y Signature of the challenge (Ry point) Private signatureS Signature of the challenge (S point) Private Scope If oldState is genesis, verifies that userID is derived from the oldUserState (= genesis state). Performed using cutId() , cutState() and isEqual() templates newUserState is different than zero using isZero() comparator oldUserState and newUserState are different using isEqual() Verifies user's identity ownership using idOwnershipBySignature(nLevels) template. The message signed by the user is H(oldstate, newstate) where H is a Poseidon hash function executed inside the Poseidon(nInputs) template Circuit Specific Files (From Trusted Setup) Final zkey circuit_final.zkey Verification Key verification_key.json WASM Witness Generator circuit.wasm authentication Github Example of instantiation coming soon! credentialAtomicQueryMTP Github Example of instantiation coming soon! credentialAtomicQuerySig Github Example of instantiation coming soon!","title":"Main Circuits"},{"location":"circuits/main-circuits/#main-circuits","text":"This iden3 circuits are the heart of the protocol. The main ones are: stateTransition.circom , checks the execution of the identity state transtion by taking the old identity state and the new identity state as inputs. authentication.circom , checks that the prover is owner of an identity. credentialAtomicQueryMTP.circom , checks that a claim issued to the prover (and added to issuer's Claims Tree) satisfies a query set by the verifier. credentialAtomicQuerySig.circom checks that a claim issued to the prover (and signed by the Issuer) satisfies a query set by the verifier. You can find all the source code on Github - Iden3 Circuits and here are the details of the Iden3 Protocol Phase2 Trusted Setup Ceremony","title":"Main Circuits"},{"location":"circuits/main-circuits/#statetransition","text":"Github Example of instantiation","title":"stateTransition"},{"location":"circuits/main-circuits/#instantiation-parameters","text":"nLevels Merkle tree depth level for Claims tree","title":"Instantiation Parameters"},{"location":"circuits/main-circuits/#inputs","text":"Input Description Public or Private userID Prover's Identifier Public oldUserState Prover's Identity State (before transition) Public newUserState Prover's Identity State (after transition) Public isOldStateGenesis \"1\" indicates that the old state is genesis: it means that this is the first State Transition, otherwise \"0\" Public claimsTreeRoot Prover's Claims Tree Root Private authClaimMtp[nLevels] Merkle Tree Proof of Auth Claim inside Prover's Claims tree Private authClaim[8] Prover's Auth Claim Private revTreeRoot Prover's Revocation Tree Root Private authClaimNonRevMtp[nLevels] Merkle Tree Proof of non membership of Auth Claim inside Prover's Revocation Tree Private authClaimNonRevMtpNoAux Flag that indicates whether to check the auxiliary Node Private authClaimNonRevMtpAuxHv Auxiliary Node Value Private authClaimNonRevMtpAuxHi Auxiliary Node Index Private rootsTreeRoot Prover's Roots Tree Root Private signatureR8x Signature of the challenge (Rx point) Private signatureR8y Signature of the challenge (Ry point) Private signatureS Signature of the challenge (S point) Private","title":"Inputs"},{"location":"circuits/main-circuits/#scope","text":"If oldState is genesis, verifies that userID is derived from the oldUserState (= genesis state). Performed using cutId() , cutState() and isEqual() templates newUserState is different than zero using isZero() comparator oldUserState and newUserState are different using isEqual() Verifies user's identity ownership using idOwnershipBySignature(nLevels) template. The message signed by the user is H(oldstate, newstate) where H is a Poseidon hash function executed inside the Poseidon(nInputs) template","title":"Scope"},{"location":"circuits/main-circuits/#circuit-specific-files-from-trusted-setup","text":"Final zkey circuit_final.zkey Verification Key verification_key.json WASM Witness Generator circuit.wasm","title":"Circuit Specific Files (From Trusted Setup)"},{"location":"circuits/main-circuits/#authentication","text":"Github Example of instantiation coming soon!","title":"authentication"},{"location":"circuits/main-circuits/#credentialatomicquerymtp","text":"Github Example of instantiation coming soon!","title":"credentialAtomicQueryMTP"},{"location":"circuits/main-circuits/#credentialatomicquerysig","text":"Github Example of instantiation coming soon!","title":"credentialAtomicQuerySig"},{"location":"circuits/template-circuits/","text":"Template Circuits The template circuits are not are not used independently inside Iden3 protocols but rather as a building blocks inside the main circuits. Note: not all the templates are described here but only a few of them. Check Iden3 Circuits and Iden3 Circomlib to see all the templates. idOwnershipBySignature Github Inputs Input Description userState Identity State of the prover userClaimsTreeRoot Prover's Claims Tree Root userAuthClaimMtp[nLevels] Merkle Tree Proof of Auth Claim inside Prover's Claims tree userAuthClaim[8] Prover's Auth Claim userRevTreeRoot Prover's Revocation Tree Root userAuthClaimNonRevMtp[nLevels] Merkle Tree Proof of non membership of Auth Claim inside Prover's Revocation Tree userAuthClaimNonRevMtpNoAux Flag that indicates whether to check the auxiliary Node userAuthClaimNonRevMtpAuxHi Auxiliary Node Index userAuthClaimNonRevMtpAuxHv Auxiliary Node Value userRootsTreeRoot Prover's Roots Tree Root challenge Message to be signed by the prover challengeSignatureR8x Signature of the challenge (Rx point) challengeSignatureR8y Signature of the challenge (Ry point) challengeSignatureS Signature of the challenge (S point) Scope Verifies that the signature was performed by the key contained in the authClaim and performs further verification on the auth claim using the VerifyAuthClaimAndSignature(nLevels) template The state generated by hashing the three roots should match the expected state from the blockchain (or be the genesis state) using the checkIdenStateMatchesRoots() template VerifyAuthClaimAndSignature Github Inputs Input Description claimsTreeRoot Prover's Claims Tree Root authClaimMtp[nLevels] Merkle Tree Proof of Auth Claim inside Prover's Claims tree authClaim[8] Prover's Auth Claim revTreeRoot Prover's Revocation Tree Root userAuthClaimNonRevMtp[nLevels] Merkle Tree Proof of non membership of Auth Claim inside Prover's Revocation Tree userAuthClaimNonRevMtpNoAux Flag that indicates whether to check the auxiliary Node userAuthClaimNonRevMtpAuxHi Auxiliary Node Index userAuthClaimNonRevMtpAuxHv Auxiliary Node Value challenge Message to be signed by the prover challengeSignatureR8x Signature of the challenge (Rx point) challengeSignatureR8y Signature of the challenge (Ry point) challengeSignatureS Signature of the challenge (S point) Scope The schema hash of the claim must match the expected AUTH_SCHEMA_HASH (hardcoded inside the circuit). Verification performed using the verifyCredentialSchema() template The authClaim exists inside the claims tree root by using the checkClaimExists() template The authClaim hasn't been revoked, namely verifies that the authClaim is not included inside the revocation tree root, using the checkClaimNotRevoked() template Verifies that the signature on the challenge has been performed by the publickey contained in the authClaim using the checkDataSignatureWithPubKeyInClaim() template","title":"Template Circuits"},{"location":"circuits/template-circuits/#template-circuits","text":"The template circuits are not are not used independently inside Iden3 protocols but rather as a building blocks inside the main circuits. Note: not all the templates are described here but only a few of them. Check Iden3 Circuits and Iden3 Circomlib to see all the templates.","title":"Template Circuits"},{"location":"circuits/template-circuits/#idownershipbysignature","text":"Github","title":"idOwnershipBySignature"},{"location":"circuits/template-circuits/#inputs","text":"Input Description userState Identity State of the prover userClaimsTreeRoot Prover's Claims Tree Root userAuthClaimMtp[nLevels] Merkle Tree Proof of Auth Claim inside Prover's Claims tree userAuthClaim[8] Prover's Auth Claim userRevTreeRoot Prover's Revocation Tree Root userAuthClaimNonRevMtp[nLevels] Merkle Tree Proof of non membership of Auth Claim inside Prover's Revocation Tree userAuthClaimNonRevMtpNoAux Flag that indicates whether to check the auxiliary Node userAuthClaimNonRevMtpAuxHi Auxiliary Node Index userAuthClaimNonRevMtpAuxHv Auxiliary Node Value userRootsTreeRoot Prover's Roots Tree Root challenge Message to be signed by the prover challengeSignatureR8x Signature of the challenge (Rx point) challengeSignatureR8y Signature of the challenge (Ry point) challengeSignatureS Signature of the challenge (S point)","title":"Inputs"},{"location":"circuits/template-circuits/#scope","text":"Verifies that the signature was performed by the key contained in the authClaim and performs further verification on the auth claim using the VerifyAuthClaimAndSignature(nLevels) template The state generated by hashing the three roots should match the expected state from the blockchain (or be the genesis state) using the checkIdenStateMatchesRoots() template","title":"Scope"},{"location":"circuits/template-circuits/#verifyauthclaimandsignature","text":"Github","title":"VerifyAuthClaimAndSignature"},{"location":"circuits/template-circuits/#inputs_1","text":"Input Description claimsTreeRoot Prover's Claims Tree Root authClaimMtp[nLevels] Merkle Tree Proof of Auth Claim inside Prover's Claims tree authClaim[8] Prover's Auth Claim revTreeRoot Prover's Revocation Tree Root userAuthClaimNonRevMtp[nLevels] Merkle Tree Proof of non membership of Auth Claim inside Prover's Revocation Tree userAuthClaimNonRevMtpNoAux Flag that indicates whether to check the auxiliary Node userAuthClaimNonRevMtpAuxHi Auxiliary Node Index userAuthClaimNonRevMtpAuxHv Auxiliary Node Value challenge Message to be signed by the prover challengeSignatureR8x Signature of the challenge (Rx point) challengeSignatureR8y Signature of the challenge (Ry point) challengeSignatureS Signature of the challenge (S point)","title":"Inputs"},{"location":"circuits/template-circuits/#scope_1","text":"The schema hash of the claim must match the expected AUTH_SCHEMA_HASH (hardcoded inside the circuit). Verification performed using the verifyCredentialSchema() template The authClaim exists inside the claims tree root by using the checkClaimExists() template The authClaim hasn't been revoked, namely verifies that the authClaim is not included inside the revocation tree root, using the checkClaimNotRevoked() template Verifies that the signature on the challenge has been performed by the publickey contained in the authClaim using the checkDataSignatureWithPubKeyInClaim() template","title":"Scope"},{"location":"contracts/overview/","text":"Smart Contracts State contract addresses: Ropsten: 0xA53E04be47e7BCe94c2f391E4560618D3199f514 Mumbai: 0x46Fd04eEa588a3EA7e9F055dd691C688c4148ab3 Polygon Mainnet: 0xb8a86e138C3fe64CbCba9731216B1a638EEc55c8 State.sol - Github The core role of State smart contract is to: Verify the proof on-chain via its transitState function If valid, update the identities mapping, adding the new identity state associated with a specific identifier. The State contract provides a timestamp of the changes that occur inside an identity state. No personal information (such as claims) is stored on-chain nor it is inferrable from the information stored on-chain. Note that the actual proof verification is executed by calling the verifyProof function inside the verifier.sol . The verifier.sol contract is automatically generated using SnarkJS and can be used as a standalone contract to verify the proof. State.sol implements further logic once the proof is verified (such as updating the identity state).","title":"Overview"},{"location":"contracts/overview/#smart-contracts","text":"State contract addresses: Ropsten: 0xA53E04be47e7BCe94c2f391E4560618D3199f514 Mumbai: 0x46Fd04eEa588a3EA7e9F055dd691C688c4148ab3 Polygon Mainnet: 0xb8a86e138C3fe64CbCba9731216B1a638EEc55c8 State.sol - Github The core role of State smart contract is to: Verify the proof on-chain via its transitState function If valid, update the identities mapping, adding the new identity state associated with a specific identifier. The State contract provides a timestamp of the changes that occur inside an identity state. No personal information (such as claims) is stored on-chain nor it is inferrable from the information stored on-chain. Note that the actual proof verification is executed by calling the verifyProof function inside the verifier.sol . The verifier.sol contract is automatically generated using SnarkJS and can be used as a standalone contract to verify the proof. State.sol implements further logic once the proof is verified (such as updating the identity state).","title":"Smart Contracts"},{"location":"getting-started/babyjubjub/","text":"Baby Jubjub Key Pair In Iden3 Protocol the public and private key pair is used to manage an identity and to authenticate in the name of an identity. In particular, Baby Jubjub is the elliptic curve used in Iden3. This curve is designed to work efficiently with zkSNARKs. Initiate a Go Module go mod init example/iden3-tutorial Update the required dependencies. go get github.com/iden3/go-iden3-crypto/babyjub Generate a baby jubjub public key. package main import ( \"fmt\" \"github.com/iden3/go-iden3-crypto/babyjub\" ) // BabyJubJub key func main () { // generate babyJubjub private key randomly babyJubjubPrivKey := babyjub . NewRandPrivKey () // generate public key from private key babyJubjubPubKey := babyJubjubPrivKey . Public () // print public key fmt . Println ( babyJubjubPubKey ) } Here is an example of a public key generated using Baby Jubjub: 500d43e1c3daa864995a9615b6f9e3a4fd0af018548c583773b6e422b14201a3 The executable code can be found here","title":"Baby Jubjub Keypair"},{"location":"getting-started/babyjubjub/#baby-jubjub-key-pair","text":"In Iden3 Protocol the public and private key pair is used to manage an identity and to authenticate in the name of an identity. In particular, Baby Jubjub is the elliptic curve used in Iden3. This curve is designed to work efficiently with zkSNARKs. Initiate a Go Module go mod init example/iden3-tutorial Update the required dependencies. go get github.com/iden3/go-iden3-crypto/babyjub Generate a baby jubjub public key. package main import ( \"fmt\" \"github.com/iden3/go-iden3-crypto/babyjub\" ) // BabyJubJub key func main () { // generate babyJubjub private key randomly babyJubjubPrivKey := babyjub . NewRandPrivKey () // generate public key from private key babyJubjubPubKey := babyJubjubPrivKey . Public () // print public key fmt . Println ( babyJubjubPubKey ) } Here is an example of a public key generated using Baby Jubjub: 500d43e1c3daa864995a9615b6f9e3a4fd0af018548c583773b6e422b14201a3 The executable code can be found here","title":"Baby Jubjub Key Pair"},{"location":"getting-started/getting-started/","text":"Introduction The role of the issuer is to create any type of identity related information in the form of claim. Claims can be viewed as Soul Bound Tokens (SBTs) on steroids. Similar to SBTs, the ownership is cryptographically guaranteed allowing control and reusability across platforms. Differently to SBTs, claims live off-chain ensuring users privacy over their Personal Identifiable Information. The first part of the tutorial walks you through the core components of Iden3 protocol necessary to initiate an identity and design claims: Baby Jubjub Keypair Sparse Merkle Tree Claim Identity Having understood the primitives you will be then able to start issuing claims . The tutorial follows a cascade strucuture: each step relies on the data and code snippets generated in the previous ones. The full executable code can be found here Iden3 Go Core Libraries Go Iden3 core - Identity core primitives Go Iden3 crypto - Implementation of Poseidon hash and Baby JubJub Elliptic curve Go Merkletree sql - Implementation of Sparse Merkle tree Go circuits - A library for transforming the go-core primitives to json inputs for identity circuits Other useful resources Circom2 - A compiler written in Rust for compiling circuits written in the Circom language SnarkJS - An npm package that contains APIs to generate and validate zk proofs generated by Circom GoLang Intro - Recommended if you are not proficient with GoLang","title":"Introduction"},{"location":"getting-started/getting-started/#introduction","text":"The role of the issuer is to create any type of identity related information in the form of claim. Claims can be viewed as Soul Bound Tokens (SBTs) on steroids. Similar to SBTs, the ownership is cryptographically guaranteed allowing control and reusability across platforms. Differently to SBTs, claims live off-chain ensuring users privacy over their Personal Identifiable Information. The first part of the tutorial walks you through the core components of Iden3 protocol necessary to initiate an identity and design claims: Baby Jubjub Keypair Sparse Merkle Tree Claim Identity Having understood the primitives you will be then able to start issuing claims . The tutorial follows a cascade strucuture: each step relies on the data and code snippets generated in the previous ones. The full executable code can be found here","title":"Introduction"},{"location":"getting-started/getting-started/#iden3-go-core-libraries","text":"Go Iden3 core - Identity core primitives Go Iden3 crypto - Implementation of Poseidon hash and Baby JubJub Elliptic curve Go Merkletree sql - Implementation of Sparse Merkle tree Go circuits - A library for transforming the go-core primitives to json inputs for identity circuits","title":"Iden3 Go Core Libraries"},{"location":"getting-started/getting-started/#other-useful-resources","text":"Circom2 - A compiler written in Rust for compiling circuits written in the Circom language SnarkJS - An npm package that contains APIs to generate and validate zk proofs generated by Circom GoLang Intro - Recommended if you are not proficient with GoLang","title":"Other useful resources"},{"location":"getting-started/issue-claim-overview/","text":"Overview In the last section, you have initiated an identity and created different types of claims. As of now, the claims haven\u2019t been published or issued in any way. The goal of this section is to issue claims so that the receiver can start using them within other applications. Starting from the same core claim there are two ways of issuing it: via Signature or via Merkle tree. Via Signature The claim gets signed by the issuer using her private key. The proof of issuance is the signature itself. This action doesn\u2019t modify the identity state of the issuer, so there\u2019s no on-chain transaction involved. Via Merkle tree The claim gets added to the issuer\u2019s Claims Tree . This action modifies the structure of the Merkle Tree and, therefore, the state has to be updated with the new Merkle root. The state transition involves an on-chain transaction. In this case, the proof of issuance is the membership of the claim iself inside the issuer\u2019s Claims Tree. Similarities and Differences Both approaches guarantee that the claim is tamper-resistant. The private zk-based verification of the claim is equally guaranteed in both cases. The process of updating the on-chain state (in the case of Merkle Tree (MT)) may take around 10/20 seconds, so the claim could not be immediately available to use for the user. Instead, with Signature (S), the claim is immediately ready for use. The biggest advantage of MT approach is that it offers timestamp proof of an identity state: a user could always prove the existence of a claim at a specific point in time according to the block number when it was added to the issuer tree. Naturally, this comes at a cost: the gas fees needed to update the state (458,228 gas used inside the transaction). No on-chain transactions take place in the case of S. A further element of difference regards the uniqueness of the claim: in the MT case, there couldn\u2019t be two claims with the same index Claim Data Structure . This is guaranteed by the characteristic of Sparse Merkle Tree . With S, an issuer could sign as many claims they want with the same index. Let\u2019s consider an example: a passport issued as a claim. This claim contains the identifier of the passport owner inside its index. MT approach provides a cryptographic guarantee that the issuer cannot duplicate the passport by issuing a claim with the same identifier. S doesn\u2019t. Note: This section describes the claim issuance on a protocol level. The way in which issuers and users\u2019 wallets communicate and transfer claims is defined on a platform level. This will be the subject of Polygon ID light issuer tutorial coming out this Autumn.","title":"Overview"},{"location":"getting-started/issue-claim-overview/#overview","text":"In the last section, you have initiated an identity and created different types of claims. As of now, the claims haven\u2019t been published or issued in any way. The goal of this section is to issue claims so that the receiver can start using them within other applications. Starting from the same core claim there are two ways of issuing it: via Signature or via Merkle tree.","title":"Overview"},{"location":"getting-started/issue-claim-overview/#via-signature","text":"The claim gets signed by the issuer using her private key. The proof of issuance is the signature itself. This action doesn\u2019t modify the identity state of the issuer, so there\u2019s no on-chain transaction involved.","title":"Via Signature"},{"location":"getting-started/issue-claim-overview/#via-merkle-tree","text":"The claim gets added to the issuer\u2019s Claims Tree . This action modifies the structure of the Merkle Tree and, therefore, the state has to be updated with the new Merkle root. The state transition involves an on-chain transaction. In this case, the proof of issuance is the membership of the claim iself inside the issuer\u2019s Claims Tree.","title":"Via Merkle tree"},{"location":"getting-started/issue-claim-overview/#similarities-and-differences","text":"Both approaches guarantee that the claim is tamper-resistant. The private zk-based verification of the claim is equally guaranteed in both cases. The process of updating the on-chain state (in the case of Merkle Tree (MT)) may take around 10/20 seconds, so the claim could not be immediately available to use for the user. Instead, with Signature (S), the claim is immediately ready for use. The biggest advantage of MT approach is that it offers timestamp proof of an identity state: a user could always prove the existence of a claim at a specific point in time according to the block number when it was added to the issuer tree. Naturally, this comes at a cost: the gas fees needed to update the state (458,228 gas used inside the transaction). No on-chain transactions take place in the case of S. A further element of difference regards the uniqueness of the claim: in the MT case, there couldn\u2019t be two claims with the same index Claim Data Structure . This is guaranteed by the characteristic of Sparse Merkle Tree . With S, an issuer could sign as many claims they want with the same index. Let\u2019s consider an example: a passport issued as a claim. This claim contains the identifier of the passport owner inside its index. MT approach provides a cryptographic guarantee that the issuer cannot duplicate the passport by issuing a claim with the same identifier. S doesn\u2019t. Note: This section describes the claim issuance on a protocol level. The way in which issuers and users\u2019 wallets communicate and transfer claims is defined on a platform level. This will be the subject of Polygon ID light issuer tutorial coming out this Autumn.","title":"Similarities and Differences"},{"location":"getting-started/mt/","text":"Sparse Merkle Tree A Merkle Tree or a hash tree is a cryptographically verifiable data structure where every \"leaf\" node of the tree contains the cryptographic hash of a data block, and every non-leaf node contains the cryptographic hash of its child nodes. The Merkle Trees used in Iden3 protocol are Sparse. In Sparse Merkle Trees each data block has an index associated to it that determines its position as leaf inside the tree. In addition to inheriting the tamper-resistance and proof-of-membership properties from standard merkle trees, a Sparse Merkle Tree has other features: The insert order of data blocks doesn't influence the final Merkle Tree Root. A data block A with index 1 and a data block B with index 4 will always occupy the same positions inside the tree despite the insert order Some leaves remain empty It's possible to prove that certain data is not included in the tree ( proof of non-membership ) A Sparse Merkle Tree is the core data structure used in Iden3 protocol to represent an identity. In particular, the leaves of a Sparse Merkle Tree are the claims issued by an identity. Update the required dependencies. go get github.com/iden3/go-merkletree-sql Design a Sparse Merkle Tree. package main import ( \"context\" \"fmt\" \"math/big\" merkletree \"github.com/iden3/go-merkletree-sql\" \"github.com/iden3/go-merkletree-sql/db/memory\" ) // Sparse MT func main () { ctx := context . Background () // Tree storage store := memory . NewMemoryStorage () // Generate a new MerkleTree with 32 levels mt , _ := merkletree . NewMerkleTree ( ctx , store , 32 ) // Add a leaf to the tree with index 1 and value 10 index1 := big . NewInt ( 1 ) value1 := big . NewInt ( 10 ) mt . Add ( ctx , index1 , value1 ) // Add another leaf to the tree index2 := big . NewInt ( 2 ) value2 := big . NewInt ( 15 ) mt . Add ( ctx , index2 , value2 ) // Proof of membership of a leaf with index 1 proofExist , value , _ := mt . GenerateProof ( ctx , index1 , mt . Root ()) fmt . Println ( \"Proof of membership:\" , proofExist . Existence ) fmt . Println ( \"Value corresponding to the queried index:\" , value ) // Proof of non-membership of a leaf with index 4 proofNotExist , _ , _ := mt . GenerateProof ( ctx , big . NewInt ( 4 ), mt . Root ()) fmt . Println ( \"Proof of membership:\" , proofNotExist . Existence ) } A data block inside the tree is represented by a index and a value . The index represents the position in the tree and it must be unique. The value represents the associated value stored in the tree. The GenerateProof method shown above allows verifying the membership of a leaf in the merkle tree starting from its root. The executable code can be found here","title":"Sparse Merkle Tree"},{"location":"getting-started/mt/#sparse-merkle-tree","text":"A Merkle Tree or a hash tree is a cryptographically verifiable data structure where every \"leaf\" node of the tree contains the cryptographic hash of a data block, and every non-leaf node contains the cryptographic hash of its child nodes. The Merkle Trees used in Iden3 protocol are Sparse. In Sparse Merkle Trees each data block has an index associated to it that determines its position as leaf inside the tree. In addition to inheriting the tamper-resistance and proof-of-membership properties from standard merkle trees, a Sparse Merkle Tree has other features: The insert order of data blocks doesn't influence the final Merkle Tree Root. A data block A with index 1 and a data block B with index 4 will always occupy the same positions inside the tree despite the insert order Some leaves remain empty It's possible to prove that certain data is not included in the tree ( proof of non-membership ) A Sparse Merkle Tree is the core data structure used in Iden3 protocol to represent an identity. In particular, the leaves of a Sparse Merkle Tree are the claims issued by an identity. Update the required dependencies. go get github.com/iden3/go-merkletree-sql Design a Sparse Merkle Tree. package main import ( \"context\" \"fmt\" \"math/big\" merkletree \"github.com/iden3/go-merkletree-sql\" \"github.com/iden3/go-merkletree-sql/db/memory\" ) // Sparse MT func main () { ctx := context . Background () // Tree storage store := memory . NewMemoryStorage () // Generate a new MerkleTree with 32 levels mt , _ := merkletree . NewMerkleTree ( ctx , store , 32 ) // Add a leaf to the tree with index 1 and value 10 index1 := big . NewInt ( 1 ) value1 := big . NewInt ( 10 ) mt . Add ( ctx , index1 , value1 ) // Add another leaf to the tree index2 := big . NewInt ( 2 ) value2 := big . NewInt ( 15 ) mt . Add ( ctx , index2 , value2 ) // Proof of membership of a leaf with index 1 proofExist , value , _ := mt . GenerateProof ( ctx , index1 , mt . Root ()) fmt . Println ( \"Proof of membership:\" , proofExist . Existence ) fmt . Println ( \"Value corresponding to the queried index:\" , value ) // Proof of non-membership of a leaf with index 4 proofNotExist , _ , _ := mt . GenerateProof ( ctx , big . NewInt ( 4 ), mt . Root ()) fmt . Println ( \"Proof of membership:\" , proofNotExist . Existence ) } A data block inside the tree is represented by a index and a value . The index represents the position in the tree and it must be unique. The value represents the associated value stored in the tree. The GenerateProof method shown above allows verifying the membership of a leaf in the merkle tree starting from its root. The executable code can be found here","title":"Sparse Merkle Tree"},{"location":"getting-started/claim/auth-claim/","text":"Key Authorization Claim The most important building block of an identity is the Key Authorization Claim. This claim stores user's Baby Jubjub public key. An Auth Claim must be included as a leaf inside the Identity Tree. All the actions performed by an Idenitity (such as claim issuance or revocation) require users to prove via a digital signature that they own the private key associated with the public key stored in the AuthClaim . Define the claim schema. The auth schema is pre-defined and should always be the same when creating an AuthClaim . The schema hash is: ca938857241db9451ea329256b9c06e5 . According to the this schema, the X and Y coordinate of the Baby Jubjub public key must be stored, respectively, in the first and second index data slot. Generate an AuthClaim. package main import ( \"encoding/json\" \"fmt\" \"github.com/iden3/go-iden3-core\" \"github.com/iden3/go-iden3-crypto/babyjub\" ) // Create auth claim func main () { authSchemaHash , _ := core . NewSchemaHashFromHex ( \"ca938857241db9451ea329256b9c06e5\" ) // Add revocation nonce. Used to invalidate the claim. This may be a random number in the real implementation. revNonce := uint64 ( 1 ) // Create auth Claim authClaim , _ := core . NewClaim ( authSchemaHash , core . WithIndexDataInts ( babyJubjubPubKey . X , babyJubjubPubKey . Y ), core . WithRevocationNonce ( revNonce )) authClaimToMarshal , _ := json . Marshal ( authClaim ) fmt . Println ( string ( authClaimToMarshal )) } Here is what the claim would look like: Claim: [\"304427537360709784173770334266246861770\",\"0\",\"12360031355466667401641753955380306964012305931931806442343193949747916655340\",\"7208907202894542671711125895887320665787554014901011121180092863817137691080\",\"1\",\"0\",\"0\",\"0\"] Let us destructure the output: Index: { \"304427537360709784173770334266246861770\", // Schema hash \"0\", \"12360031355466667401641753955380306964012305931931806442343193949747916655340\", // X coordinate of the pubkey \"7208907202894542671711125895887320665787554014901011121180092863817137691080\" // Y coordinate of the pubkey } Value: { \"1\", // revocation nonce \"0\", \"0\", // first value data slot \"0\" // second value data slot } The data stored in position 1 of the Value contains the Revocation Nonce. This value will be used to revoke/invalidate an AuthClaim . More on that in the next section. The executable code can be found here","title":"Auth Claim"},{"location":"getting-started/claim/auth-claim/#key-authorization-claim","text":"The most important building block of an identity is the Key Authorization Claim. This claim stores user's Baby Jubjub public key. An Auth Claim must be included as a leaf inside the Identity Tree. All the actions performed by an Idenitity (such as claim issuance or revocation) require users to prove via a digital signature that they own the private key associated with the public key stored in the AuthClaim . Define the claim schema. The auth schema is pre-defined and should always be the same when creating an AuthClaim . The schema hash is: ca938857241db9451ea329256b9c06e5 . According to the this schema, the X and Y coordinate of the Baby Jubjub public key must be stored, respectively, in the first and second index data slot. Generate an AuthClaim. package main import ( \"encoding/json\" \"fmt\" \"github.com/iden3/go-iden3-core\" \"github.com/iden3/go-iden3-crypto/babyjub\" ) // Create auth claim func main () { authSchemaHash , _ := core . NewSchemaHashFromHex ( \"ca938857241db9451ea329256b9c06e5\" ) // Add revocation nonce. Used to invalidate the claim. This may be a random number in the real implementation. revNonce := uint64 ( 1 ) // Create auth Claim authClaim , _ := core . NewClaim ( authSchemaHash , core . WithIndexDataInts ( babyJubjubPubKey . X , babyJubjubPubKey . Y ), core . WithRevocationNonce ( revNonce )) authClaimToMarshal , _ := json . Marshal ( authClaim ) fmt . Println ( string ( authClaimToMarshal )) } Here is what the claim would look like: Claim: [\"304427537360709784173770334266246861770\",\"0\",\"12360031355466667401641753955380306964012305931931806442343193949747916655340\",\"7208907202894542671711125895887320665787554014901011121180092863817137691080\",\"1\",\"0\",\"0\",\"0\"] Let us destructure the output: Index: { \"304427537360709784173770334266246861770\", // Schema hash \"0\", \"12360031355466667401641753955380306964012305931931806442343193949747916655340\", // X coordinate of the pubkey \"7208907202894542671711125895887320665787554014901011121180092863817137691080\" // Y coordinate of the pubkey } Value: { \"1\", // revocation nonce \"0\", \"0\", // first value data slot \"0\" // second value data slot } The data stored in position 1 of the Value contains the Revocation Nonce. This value will be used to revoke/invalidate an AuthClaim . More on that in the next section. The executable code can be found here","title":"Key Authorization Claim"},{"location":"getting-started/claim/claim-schema/","text":"Claim Schema The reusability of claims across platforms and services is guaranteed by Claim Schema consistency. Polygon ID use JSON-LD documents to represent Claim Schemas. As an issuer it is advised to check if any of the existing claim schemas can accomodate the type of information you are interested to issue. If not, here's the guide to create a new claim schema. Let us create a shared and reusable claim schema of type ProofOfDaoMembership . Define the value to be included in the schema. The ProofOfDaoMembership claim should attest that a person covers a role inside a specific DAO. Information such as the identifier of the DAO or the identifier of the subject of the claim don't need to be encoded inside one of the four data slots allocated for claim information (i_2,i_3, v_2, v_3): The information about the specific DAO can be inferred from the claim issuer identifier The information about the individual subject of the claim is already stored in the i_1 or v_1 data slot of the claim A further information that must be included in the claim is the role of the individual inside a DAO. This will be the added inside one of the data slots (i_2,i_3,v_2,v_3). Remember that a claim can only store numeric data so each DAO role should be encoded as a number. Decide where to store this information, should it be inside index data slots or value data slots? Claim's index determines its uniqueness inside the issuer's claims tree. There cannot be more than one claim with the same index. If it is decided to store the identifier of the subject of the claim inside i_1 and leave the other index data slots empty, it means that there can only be one claim issued to a specific identity inside the tree. In this case, the question is whether to store the information with type role inside i_2 or v_2. Storing the role inside i_2 means that the uniqueness inside the tree is determined by the combination \"person identifier + role\" Storing the role inside v_2 means that the uniqueness inside the tree is only determined the person identifier Considering the possibility that a DAO member covers more than one role, it makes more sense to store the role inside i_2. This choice allow the DAO to issue subsequent claims to the same individual attesting a different role. Describe the vocabulary of the schema Create a markdown file in your repository to describe the vocabulary used in the claim. This should contain a description of the key type role and its possible values: # role Describes the role covered by an individual inside a specific DAO 1 : Contributor 2 : Guild Coordinator 3 : Team Member Create the JSON-LD document Add a file inside your repository with extension .json-ld and populate it. The @id key should contain the identifier of the Schema Type \"ProofOfDaoMembership\", in this case the unique url to the JSON-LD document. The proof-of-dao-vocab key should contain the url that describes the vocabulary of the claim schema. { \"@context\" : [{ \"@version\" : 1.1 , \"@protected\" : true , \"id\" : \"@id\" , \"type\" : \"@type\" , \"ProofOfDaoMembership\" : { \"@id\" : \"https://raw.githubusercontent.com/iden3/tutorial-examples/main/claim-schema/proof-of-dao-membership.json-ld#ProofOfDaoMembership\" , \"@context\" : { \"@version\" : 1.1 , \"@protected\" : true , \"id\" : \"@id\" , \"type\" : \"@type\" , \"proof-of-dao-vocab\" : \"https://github.com/iden3/tutorial-examples/blob/main/claim-schema/proof-of-dao.md#\" , \"serialization\" : \"https://github.com/iden3/claim-schema-vocab/blob/main/credentials/serialization.md#\" , \"type\" : { \"@id\" : \"proof-of-dao-vocab:role\" , \"@type\" : \"serialization:IndexDataSlotA\" }, } } }] } Generate the schema hash The Schema Hash has to be added inside claim's index. The schema hash is generated by hashing together schemaBytes (the JSON-LD document in byte format) and credentialType (in this case \"ProofOfDaoMembership\"). In this case: package main import ( \"fmt\" \"os\" core \"github.com/iden3/go-iden3-core\" \"github.com/iden3/go-iden3-crypto/keccak256\" ) func main () { schemaBytes , _ := os . ReadFile ( \"../proof-of-dao-membership.json-ld\" ) var sHash core . SchemaHash h := keccak256 . Hash ( schemaBytes , [] byte ( \"ProofOfDaoMembership\" )) copy ( sHash [:], h [ len ( h ) - 16 :]) sHashHex , _ := sHash . MarshalText () fmt . Println ( string ( sHashHex )) // 5a5cb158b44f6b5a132789ce1abc73ae } The executable code can be found here","title":"Claim Schema"},{"location":"getting-started/claim/claim-schema/#claim-schema","text":"The reusability of claims across platforms and services is guaranteed by Claim Schema consistency. Polygon ID use JSON-LD documents to represent Claim Schemas. As an issuer it is advised to check if any of the existing claim schemas can accomodate the type of information you are interested to issue. If not, here's the guide to create a new claim schema. Let us create a shared and reusable claim schema of type ProofOfDaoMembership . Define the value to be included in the schema. The ProofOfDaoMembership claim should attest that a person covers a role inside a specific DAO. Information such as the identifier of the DAO or the identifier of the subject of the claim don't need to be encoded inside one of the four data slots allocated for claim information (i_2,i_3, v_2, v_3): The information about the specific DAO can be inferred from the claim issuer identifier The information about the individual subject of the claim is already stored in the i_1 or v_1 data slot of the claim A further information that must be included in the claim is the role of the individual inside a DAO. This will be the added inside one of the data slots (i_2,i_3,v_2,v_3). Remember that a claim can only store numeric data so each DAO role should be encoded as a number. Decide where to store this information, should it be inside index data slots or value data slots? Claim's index determines its uniqueness inside the issuer's claims tree. There cannot be more than one claim with the same index. If it is decided to store the identifier of the subject of the claim inside i_1 and leave the other index data slots empty, it means that there can only be one claim issued to a specific identity inside the tree. In this case, the question is whether to store the information with type role inside i_2 or v_2. Storing the role inside i_2 means that the uniqueness inside the tree is determined by the combination \"person identifier + role\" Storing the role inside v_2 means that the uniqueness inside the tree is only determined the person identifier Considering the possibility that a DAO member covers more than one role, it makes more sense to store the role inside i_2. This choice allow the DAO to issue subsequent claims to the same individual attesting a different role. Describe the vocabulary of the schema Create a markdown file in your repository to describe the vocabulary used in the claim. This should contain a description of the key type role and its possible values: # role Describes the role covered by an individual inside a specific DAO 1 : Contributor 2 : Guild Coordinator 3 : Team Member Create the JSON-LD document Add a file inside your repository with extension .json-ld and populate it. The @id key should contain the identifier of the Schema Type \"ProofOfDaoMembership\", in this case the unique url to the JSON-LD document. The proof-of-dao-vocab key should contain the url that describes the vocabulary of the claim schema. { \"@context\" : [{ \"@version\" : 1.1 , \"@protected\" : true , \"id\" : \"@id\" , \"type\" : \"@type\" , \"ProofOfDaoMembership\" : { \"@id\" : \"https://raw.githubusercontent.com/iden3/tutorial-examples/main/claim-schema/proof-of-dao-membership.json-ld#ProofOfDaoMembership\" , \"@context\" : { \"@version\" : 1.1 , \"@protected\" : true , \"id\" : \"@id\" , \"type\" : \"@type\" , \"proof-of-dao-vocab\" : \"https://github.com/iden3/tutorial-examples/blob/main/claim-schema/proof-of-dao.md#\" , \"serialization\" : \"https://github.com/iden3/claim-schema-vocab/blob/main/credentials/serialization.md#\" , \"type\" : { \"@id\" : \"proof-of-dao-vocab:role\" , \"@type\" : \"serialization:IndexDataSlotA\" }, } } }] } Generate the schema hash The Schema Hash has to be added inside claim's index. The schema hash is generated by hashing together schemaBytes (the JSON-LD document in byte format) and credentialType (in this case \"ProofOfDaoMembership\"). In this case: package main import ( \"fmt\" \"os\" core \"github.com/iden3/go-iden3-core\" \"github.com/iden3/go-iden3-crypto/keccak256\" ) func main () { schemaBytes , _ := os . ReadFile ( \"../proof-of-dao-membership.json-ld\" ) var sHash core . SchemaHash h := keccak256 . Hash ( schemaBytes , [] byte ( \"ProofOfDaoMembership\" )) copy ( sHash [:], h [ len ( h ) - 16 :]) sHashHex , _ := sHash . MarshalText () fmt . Println ( string ( sHashHex )) // 5a5cb158b44f6b5a132789ce1abc73ae } The executable code can be found here","title":"Claim Schema"},{"location":"getting-started/claim/generic-claim/","text":"Generic Claim A Claim is a statement made by one identity about another identity or about itself. In general, claim is a flexible and modular data primitive that can be used to represent any identity-related information. Update the required dependencies. go get github.com/iden3/go-iden3-core Define the claim schema . A claim schema defines how a set of data must be stored inside a claim. In this example, we will use a schema called ageSchema . According to this schema the age is stored in the first index slot of the claim data structure . The hash of the schema is generated from the content of the schema document. For our example, the hash of the schema is: ce38102464833febf36e714922a83050 The age schema example is provided only for illustrative purposes. In real life, you would store some constant information like the date of birth, but not the age, which changes over time. Create a generic claim. package main import ( \"encoding/json\" \"fmt\" \"math/big\" core \"github.com/iden3/go-iden3-core\" ) // create basic claim func main () { ageSchema , _ := core . NewSchemaHashFromHex ( \"ce38102464833febf36e714922a83050\" ) // define age age := big . NewInt ( 25 ) // create claim based on the ageSchema storing the age in the first index slot, while the second data slot remains empty claim , _ := core . NewClaim ( ageSchema , core . WithIndexDataInts ( age , nil )) // transform claim from bytes array to json claimToMarshal , _ := json . Marshal ( claim ) fmt . Println ( string ( claimToMarshal )) } Here is what the claim would look like: [\"106590880073303418818490710639556704462\",\"0\",\"25\",\"0\",\"0\",\"0\",\"0\",\"0\"] In particular, the first 4 values of the claim represent the Index part of the claim while the last 4 represent the Value . Index: { \"106590880073303418818490710639556704462\", // Schema hash \"0\", \"25\", // first index data slot stores age \"0\" // second index data slot is blank } Value: { \"0\", \"0\", \"0\", // first value data slot \"0\" // second value data slot } The data stored in the first position of the Index contains a reference to the schema of the claim. As defined in the ageSchema , the value age must be stored in the first index data slot while the second index data slot and the two value data slots are left empty. Other schemas may provide different rules on where to store the data. The executable code can be found here","title":"Generic Claim"},{"location":"getting-started/claim/generic-claim/#generic-claim","text":"A Claim is a statement made by one identity about another identity or about itself. In general, claim is a flexible and modular data primitive that can be used to represent any identity-related information. Update the required dependencies. go get github.com/iden3/go-iden3-core Define the claim schema . A claim schema defines how a set of data must be stored inside a claim. In this example, we will use a schema called ageSchema . According to this schema the age is stored in the first index slot of the claim data structure . The hash of the schema is generated from the content of the schema document. For our example, the hash of the schema is: ce38102464833febf36e714922a83050 The age schema example is provided only for illustrative purposes. In real life, you would store some constant information like the date of birth, but not the age, which changes over time. Create a generic claim. package main import ( \"encoding/json\" \"fmt\" \"math/big\" core \"github.com/iden3/go-iden3-core\" ) // create basic claim func main () { ageSchema , _ := core . NewSchemaHashFromHex ( \"ce38102464833febf36e714922a83050\" ) // define age age := big . NewInt ( 25 ) // create claim based on the ageSchema storing the age in the first index slot, while the second data slot remains empty claim , _ := core . NewClaim ( ageSchema , core . WithIndexDataInts ( age , nil )) // transform claim from bytes array to json claimToMarshal , _ := json . Marshal ( claim ) fmt . Println ( string ( claimToMarshal )) } Here is what the claim would look like: [\"106590880073303418818490710639556704462\",\"0\",\"25\",\"0\",\"0\",\"0\",\"0\",\"0\"] In particular, the first 4 values of the claim represent the Index part of the claim while the last 4 represent the Value . Index: { \"106590880073303418818490710639556704462\", // Schema hash \"0\", \"25\", // first index data slot stores age \"0\" // second index data slot is blank } Value: { \"0\", \"0\", \"0\", // first value data slot \"0\" // second value data slot } The data stored in the first position of the Index contains a reference to the schema of the claim. As defined in the ageSchema , the value age must be stored in the first index data slot while the second index data slot and the two value data slots are left empty. Other schemas may provide different rules on where to store the data. The executable code can be found here","title":"Generic Claim"},{"location":"getting-started/identity/identifier/","text":"Identifier Each identity has a unique identifier. ID is: Permanent: it remains the same for the entire existence of an identity. Unique: No two identities can have the same ID. The ID is deterministically calculated from the Genesis State. Retrieve the Identifier ID package main import ( \"fmt\" core \"github.com/iden3/go-iden3-core\" ) // Retrieve ID func main () { id , _ := core . IdGenesisFromIdenState ( core . TypeDefault , state . BigInt ()) fmt . Println ( \"ID:\" , id ) } Here is what the output would look like: ID: 11AbuG9EKnWVXK1tooT2NyStQod2EnLhfccSajkwJA Hereafter, this identity is represented as a mapping: ID => IdS . This gets published, together with all other identities, inside the identities mapping, which is part of the State.sol contract . While the ID remains constant, the Identity State will get updated as soon as the identity adds or revokes claims in its trees. No Personal Identifiable Information (PPI) is stored on-chain. From the IdS is impossible to retrieve any information (represented as claim) stored inside the Identity Claims Tree The Identity State hasn't been published on-chain yet as claims haven't been issued yet. This is the subject of the next section. The executable code can be found here","title":"Identifier"},{"location":"getting-started/identity/identifier/#identifier","text":"Each identity has a unique identifier. ID is: Permanent: it remains the same for the entire existence of an identity. Unique: No two identities can have the same ID. The ID is deterministically calculated from the Genesis State. Retrieve the Identifier ID package main import ( \"fmt\" core \"github.com/iden3/go-iden3-core\" ) // Retrieve ID func main () { id , _ := core . IdGenesisFromIdenState ( core . TypeDefault , state . BigInt ()) fmt . Println ( \"ID:\" , id ) } Here is what the output would look like: ID: 11AbuG9EKnWVXK1tooT2NyStQod2EnLhfccSajkwJA Hereafter, this identity is represented as a mapping: ID => IdS . This gets published, together with all other identities, inside the identities mapping, which is part of the State.sol contract . While the ID remains constant, the Identity State will get updated as soon as the identity adds or revokes claims in its trees. No Personal Identifiable Information (PPI) is stored on-chain. From the IdS is impossible to retrieve any information (represented as claim) stored inside the Identity Claims Tree The Identity State hasn't been published on-chain yet as claims haven't been issued yet. This is the subject of the next section. The executable code can be found here","title":"Identifier"},{"location":"getting-started/identity/identity-state/","text":"Identity State An Identity State IdS is represented by the hash of the roots of these three merkle trees. IdS = H(ClR || ReR || RoR) where: H : Hashing Function ClR : Claims Tree Root ReR : Revocation Tree Root RoR : Roots Tree Root The identity state gets stored on-chain and represents the status of an identity at a certain point in time. Identity State Diagram Retrieve the Identity State IdS package main import ( \"fmt\" \"github.com/iden3/go-merkletree-sql\" ) // Retrieve Identity State func main () { // calculate Identity State as a hash of the three roots state , _ := merkletree . HashElems ( clt . Root (). BigInt (), ret . Root (). BigInt (), rot . Root (). BigInt ()) fmt . Println ( \"Identity State:\" , state ) } Here is what the output would look like: Identity State: 20698226269617404048572275736120991936409000313072409404791246779211976957795 The very first identity state of an identity is defined as Genesis State Every verification inside Iden3 protocol is executed against the Identity State. For instance, to prove the validity of a specific claim issued by A to B (in case if the claims gets added to the claims tree): user B needs to produce a merkle proof of the existence of that claim inside user's A ClR user B needs to produce a merkle proof of non existence of the corresponding revocation nonce inside user's A ReT The executable code can be found here","title":"Identity State"},{"location":"getting-started/identity/identity-state/#identity-state","text":"An Identity State IdS is represented by the hash of the roots of these three merkle trees. IdS = H(ClR || ReR || RoR) where: H : Hashing Function ClR : Claims Tree Root ReR : Revocation Tree Root RoR : Roots Tree Root The identity state gets stored on-chain and represents the status of an identity at a certain point in time. Identity State Diagram Retrieve the Identity State IdS package main import ( \"fmt\" \"github.com/iden3/go-merkletree-sql\" ) // Retrieve Identity State func main () { // calculate Identity State as a hash of the three roots state , _ := merkletree . HashElems ( clt . Root (). BigInt (), ret . Root (). BigInt (), rot . Root (). BigInt ()) fmt . Println ( \"Identity State:\" , state ) } Here is what the output would look like: Identity State: 20698226269617404048572275736120991936409000313072409404791246779211976957795 The very first identity state of an identity is defined as Genesis State Every verification inside Iden3 protocol is executed against the Identity State. For instance, to prove the validity of a specific claim issued by A to B (in case if the claims gets added to the claims tree): user B needs to produce a merkle proof of the existence of that claim inside user's A ClR user B needs to produce a merkle proof of non existence of the corresponding revocation nonce inside user's A ReT The executable code can be found here","title":"Identity State"},{"location":"getting-started/identity/identity-structure/","text":"Identity Structure Each identity consists of Three Sparse Merkle Trees : ClT : A Claims tree that contains the claims issued by that particular identity ReT : A Revocation tree that contains the revocation nonces of the claims that have been revoked by that particular identity RoT : A Roots tree that contains the history of the tree roots from the Claims tree Claims issued by an identity are added to the Claims tree (we'll see in a while why that's not always the case). The position of a claim inside the Sparse Merkle Tree is determined by the hash of the claim's Index while the value stored inside the leaf will be the hash of the claim's Value . An identity must issue at least one Auth Claim to operate properly. This is the first claim that is issued by an identity and that must be added to the ClT . Create identity trees and add authClaim package main import ( \"github.com/iden3/go-merkletree-sql\" ) // Generate the three identity trees func main () { // Create empty Claims tree clt , _ := merkletree . NewMerkleTree ( ctx , memory . NewMemoryStorage (), 32 ) // Create empty Revocation tree ret , _ := merkletree . NewMerkleTree ( ctx , memory . NewMemoryStorage (), 32 ) // Create empty Roots tree rot , _ := merkletree . NewMerkleTree ( ctx , memory . NewMemoryStorage (), 32 ) // Get the Index and the Value of the authClaim hIndex , hValue , _ := authClaim . HiHv () // add auth claim to claims tree with value hValue at index hIndex clt . Add ( ctx , hIndex , hValue ) // print the roots fmt . Println ( clt . Root (). BigInt (), ret . Root (). BigInt (), rot . Root (). BigInt ()) } We just generated the three identity trees! For now, we only added a leaf correponding to the authClaim to the Claims tree ClT . The Revocation tree ReT and the RoT remain empty. In particular: The revocation tree gets updated whenever an identity decides to revoke a claim. For instance, if a user decides to rotate her keys, then she generates a key pair, creates a new authClaim with the public key from the key pair and adds the claim to the Claims Tree. Now the user can revoke the old public key, so she adds an entry to the Revocation Tree with the claim revocation nonce as an Index and zero as a Value. The Roots Tree gets updated whenever the Identity Claims Tree root gets updated. The executable code can be found here","title":"Identity Structure"},{"location":"getting-started/identity/identity-structure/#identity-structure","text":"Each identity consists of Three Sparse Merkle Trees : ClT : A Claims tree that contains the claims issued by that particular identity ReT : A Revocation tree that contains the revocation nonces of the claims that have been revoked by that particular identity RoT : A Roots tree that contains the history of the tree roots from the Claims tree Claims issued by an identity are added to the Claims tree (we'll see in a while why that's not always the case). The position of a claim inside the Sparse Merkle Tree is determined by the hash of the claim's Index while the value stored inside the leaf will be the hash of the claim's Value . An identity must issue at least one Auth Claim to operate properly. This is the first claim that is issued by an identity and that must be added to the ClT . Create identity trees and add authClaim package main import ( \"github.com/iden3/go-merkletree-sql\" ) // Generate the three identity trees func main () { // Create empty Claims tree clt , _ := merkletree . NewMerkleTree ( ctx , memory . NewMemoryStorage (), 32 ) // Create empty Revocation tree ret , _ := merkletree . NewMerkleTree ( ctx , memory . NewMemoryStorage (), 32 ) // Create empty Roots tree rot , _ := merkletree . NewMerkleTree ( ctx , memory . NewMemoryStorage (), 32 ) // Get the Index and the Value of the authClaim hIndex , hValue , _ := authClaim . HiHv () // add auth claim to claims tree with value hValue at index hIndex clt . Add ( ctx , hIndex , hValue ) // print the roots fmt . Println ( clt . Root (). BigInt (), ret . Root (). BigInt (), rot . Root (). BigInt ()) } We just generated the three identity trees! For now, we only added a leaf correponding to the authClaim to the Claims tree ClT . The Revocation tree ReT and the RoT remain empty. In particular: The revocation tree gets updated whenever an identity decides to revoke a claim. For instance, if a user decides to rotate her keys, then she generates a key pair, creates a new authClaim with the public key from the key pair and adds the claim to the Claims Tree. Now the user can revoke the old public key, so she adds an entry to the Revocation Tree with the claim revocation nonce as an Index and zero as a Value. The Roots Tree gets updated whenever the Identity Claims Tree root gets updated. The executable code can be found here","title":"Identity Structure"},{"location":"getting-started/signature-claim/signature/","text":"Signature Claim Issuance To issue a claim by signing it, the only thing needed is access to your Baby Jubjub private key . Retrieve hash of Claim's Index and hash of Claim's Value Starting from the Generic Claim previously created the first step we first need to extract the hash of its index and the hash of its value claimIndex , claimValue := claim . RawSlots () indexHash , _ := poseidon . Hash ( core . ElemBytesToInts ( claimIndex [:])) valueHash , _ := poseidon . Hash ( core . ElemBytesToInts ( claimValue [:])) Hash the indexHash and the valueHash together and sign it // Poseidon Hash the indexHash and the valueHash together to get the claimHash claimHash , _ := merkletree . HashElems ( indexHash , valueHash ) // Sign the claimHash with the private key of the issuer claimSignature := babyJubjubPrivKey . SignPoseidon ( claimHash . BigInt ()) The executable code can be found here","title":"via Signature"},{"location":"getting-started/signature-claim/signature/#signature-claim-issuance","text":"To issue a claim by signing it, the only thing needed is access to your Baby Jubjub private key . Retrieve hash of Claim's Index and hash of Claim's Value Starting from the Generic Claim previously created the first step we first need to extract the hash of its index and the hash of its value claimIndex , claimValue := claim . RawSlots () indexHash , _ := poseidon . Hash ( core . ElemBytesToInts ( claimIndex [:])) valueHash , _ := poseidon . Hash ( core . ElemBytesToInts ( claimValue [:])) Hash the indexHash and the valueHash together and sign it // Poseidon Hash the indexHash and the valueHash together to get the claimHash claimHash , _ := merkletree . HashElems ( indexHash , valueHash ) // Sign the claimHash with the private key of the issuer claimSignature := babyJubjubPrivKey . SignPoseidon ( claimHash . BigInt ()) The executable code can be found here","title":"Signature Claim Issuance"},{"location":"getting-started/state-transition/new-identity-state/","text":"Add Claim to the Claims Tree At t=0, the situation is the same left from the Identity section of tutorial. Our identity is still at the Genesis State . The Claims Tree contains only the authClaim . The revocation and roots trees are empty. The state hasn't been published on-chain yet. Let's see what happens when if we decide to add a new claim to the Claims Tree. Update the required dependencies. go get github.com/iden3/go-circuits Add a new claim and fetch the new state package main import ( \"encoding/hex\" \"fmt\" \"math/big\" \"github.com/iden3/go-circuits\" core \"github.com/iden3/go-iden3-core\" \"github.com/iden3/go-iden3-crypto/poseidon\" \"github.com/iden3/go-merkletree-sql\" ) // Change Identity State func main () { // GENESIS STATE: // 1. Generate Merkle Tree Proof for authClaim at Genesis State authMTPProof , _ , _ := clt . GenerateProof ( ctx , hIndex , clt . Root ()) // 2. Generate the Non-Revocation Merkle tree proof for the authClaim at Genesis State authNonRevMTPProof , _ , _ := ret . GenerateProof ( ctx , new ( big . Int ). SetUint64 ( revNonce ), ret . Root ()) // Snapshot of the Genesis State genesisTreeState := circuits . TreeState { State : state , ClaimsRoot : clt . Root (), RevocationRoot : ret . Root (), RootOfRoots : rot . Root (), } // STATE 1: // Before updating the claims tree, add the claims tree root at Genesis state to the Roots tree. rot . Add ( ctx , clt . Root (). BigInt (), big . NewInt ( 0 )) // Create a new random claim schemaHex := hex . EncodeToString ([] byte ( \"myAge_test_claim\" )) schema , _ := core . NewSchemaHashFromHex ( schemaHex ) code := big . NewInt ( 51 ) newClaim , _ := core . NewClaim ( schema , core . WithIndexDataInts ( code , nil )) // Get hash Index and hash Value of the new claim hi , hv , _ := newClaim . HiHv () // Add claim to the Claims tree clt . Add ( ctx , hi , hv ) // Fetch the new Identity State newState , _ := merkletree . HashElems ( clt . Root (). BigInt (), ret . Root (). BigInt (), rot . Root (). BigInt ()) // Sign a message (hash of the genesis state + the new state) using your private key hashOldAndNewStates , _ := poseidon . Hash ([] * big . Int { state . BigInt (), newState . BigInt ()}) signature := babyJubjubPrivKey . SignPoseidon ( hashOldAndNewStates ) // Generate state transition inputs stateTransitionInputs := circuits . StateTransitionInputs { ID : id , OldTreeState : genesisTreeState , NewState : newState , IsOldStateGenesis : true , AuthClaim : circuits . Claim { Claim : authClaim , Proof : authMTPProof , NonRevProof : & circuits . ClaimNonRevStatus { Proof : authNonRevMTPProof , }, }, Signature : signature , } // Perform marshalling of the state transition inputs inputBytes , _ := stateTransitionInputs . InputsMarshal () fmt . Println ( string ( inputBytes )) } After issuing a new claim, the claims tree gets modified and, therefore, the Identity State changes. To complete the state transition it is necessary to verify it inside a circuit. The type StateTransitionInputs lets us pack the inputs needed to generate a proof while the InputsMarshal() function turns it into a json file that can be used directly as State Transition Circuit inputs. These inputs will be used in the next section. The executable code can be found here","title":"Add Claim to the Claims Tree"},{"location":"getting-started/state-transition/new-identity-state/#add-claim-to-the-claims-tree","text":"At t=0, the situation is the same left from the Identity section of tutorial. Our identity is still at the Genesis State . The Claims Tree contains only the authClaim . The revocation and roots trees are empty. The state hasn't been published on-chain yet. Let's see what happens when if we decide to add a new claim to the Claims Tree. Update the required dependencies. go get github.com/iden3/go-circuits Add a new claim and fetch the new state package main import ( \"encoding/hex\" \"fmt\" \"math/big\" \"github.com/iden3/go-circuits\" core \"github.com/iden3/go-iden3-core\" \"github.com/iden3/go-iden3-crypto/poseidon\" \"github.com/iden3/go-merkletree-sql\" ) // Change Identity State func main () { // GENESIS STATE: // 1. Generate Merkle Tree Proof for authClaim at Genesis State authMTPProof , _ , _ := clt . GenerateProof ( ctx , hIndex , clt . Root ()) // 2. Generate the Non-Revocation Merkle tree proof for the authClaim at Genesis State authNonRevMTPProof , _ , _ := ret . GenerateProof ( ctx , new ( big . Int ). SetUint64 ( revNonce ), ret . Root ()) // Snapshot of the Genesis State genesisTreeState := circuits . TreeState { State : state , ClaimsRoot : clt . Root (), RevocationRoot : ret . Root (), RootOfRoots : rot . Root (), } // STATE 1: // Before updating the claims tree, add the claims tree root at Genesis state to the Roots tree. rot . Add ( ctx , clt . Root (). BigInt (), big . NewInt ( 0 )) // Create a new random claim schemaHex := hex . EncodeToString ([] byte ( \"myAge_test_claim\" )) schema , _ := core . NewSchemaHashFromHex ( schemaHex ) code := big . NewInt ( 51 ) newClaim , _ := core . NewClaim ( schema , core . WithIndexDataInts ( code , nil )) // Get hash Index and hash Value of the new claim hi , hv , _ := newClaim . HiHv () // Add claim to the Claims tree clt . Add ( ctx , hi , hv ) // Fetch the new Identity State newState , _ := merkletree . HashElems ( clt . Root (). BigInt (), ret . Root (). BigInt (), rot . Root (). BigInt ()) // Sign a message (hash of the genesis state + the new state) using your private key hashOldAndNewStates , _ := poseidon . Hash ([] * big . Int { state . BigInt (), newState . BigInt ()}) signature := babyJubjubPrivKey . SignPoseidon ( hashOldAndNewStates ) // Generate state transition inputs stateTransitionInputs := circuits . StateTransitionInputs { ID : id , OldTreeState : genesisTreeState , NewState : newState , IsOldStateGenesis : true , AuthClaim : circuits . Claim { Claim : authClaim , Proof : authMTPProof , NonRevProof : & circuits . ClaimNonRevStatus { Proof : authNonRevMTPProof , }, }, Signature : signature , } // Perform marshalling of the state transition inputs inputBytes , _ := stateTransitionInputs . InputsMarshal () fmt . Println ( string ( inputBytes )) } After issuing a new claim, the claims tree gets modified and, therefore, the Identity State changes. To complete the state transition it is necessary to verify it inside a circuit. The type StateTransitionInputs lets us pack the inputs needed to generate a proof while the InputsMarshal() function turns it into a json file that can be used directly as State Transition Circuit inputs. These inputs will be used in the next section. The executable code can be found here","title":"Add Claim to the Claims Tree"},{"location":"getting-started/state-transition/on-chain-state-transition-remix/","text":"Remix Connect yout Metamask wallet to Polygon Mumbai Testnet. On the Remix Homepage , click \"Load from GitHub\" and import State.sol using the link: https://github.com/iden3/contracts/blob/master/contracts/State.sol Move to the \"Solidity Compiler\" section and compile State.sol . Move to the \"Deploy and Run Transaction\" section and modify the Environment to \"Injected web3\". If everything was set correctly, you should see Custom (80001) network below the environment drop-down menu.The system prompts you to connect to your MetaMask wallet. Make sure to select the \"Mumbai\" network on your Metamask before connecting the wallet. Make sure that the State contract is selected in the contract drop-down menu and \"Load contract from address\" adding 0x46Fd04eEa588a3EA7e9F055dd691C688c4148ab3 as contract address. Check identity state at T=0. To check the identity state call the getState function on the State.sol passing in your identifier. The identifier is the first public input in the public array returned from the solidity calldata from the previous tutorial. The result is zero as there's no identity state associated with that identifier because the identity state has never been published on-chain (yet!) Now update the identity state by calling the transitState function on State.sol. The outputs generated from the previous tutorial are passed as inputs to the transitState function. See the one-to-one mapping between the outputs from state transition and the inputs to the transitState function in the diagram below: transitState Function Inputs Check the new state. To check, call the getState function again by passing the value of the identifier you used above as an input to the transitState function. You can see that the console displays a new state: uint256:14531895531750268543323474544059484523319511522635242711319115705040584883009","title":"On chain state transition remix"},{"location":"getting-started/state-transition/on-chain-state-transition-remix/#remix","text":"Connect yout Metamask wallet to Polygon Mumbai Testnet. On the Remix Homepage , click \"Load from GitHub\" and import State.sol using the link: https://github.com/iden3/contracts/blob/master/contracts/State.sol Move to the \"Solidity Compiler\" section and compile State.sol . Move to the \"Deploy and Run Transaction\" section and modify the Environment to \"Injected web3\". If everything was set correctly, you should see Custom (80001) network below the environment drop-down menu.The system prompts you to connect to your MetaMask wallet. Make sure to select the \"Mumbai\" network on your Metamask before connecting the wallet. Make sure that the State contract is selected in the contract drop-down menu and \"Load contract from address\" adding 0x46Fd04eEa588a3EA7e9F055dd691C688c4148ab3 as contract address. Check identity state at T=0. To check the identity state call the getState function on the State.sol passing in your identifier. The identifier is the first public input in the public array returned from the solidity calldata from the previous tutorial. The result is zero as there's no identity state associated with that identifier because the identity state has never been published on-chain (yet!) Now update the identity state by calling the transitState function on State.sol. The outputs generated from the previous tutorial are passed as inputs to the transitState function. See the one-to-one mapping between the outputs from state transition and the inputs to the transitState function in the diagram below: transitState Function Inputs Check the new state. To check, call the getState function again by passing the value of the identifier you used above as an input to the transitState function. You can see that the console displays a new state: uint256:14531895531750268543323474544059484523319511522635242711319115705040584883009","title":"Remix"},{"location":"getting-started/state-transition/on-chain-state-transition/","text":"Verify the Proof On-Chain In order to complete the State Transition process it is necessary to verify the proof inside the State.sol contract. The transitState public function of the contract takes the proof generated in the previous section and verifies it on-chain. On verification, the identities mapping associated with the ID that is executing the transition gets updated. Hardhat Add Mumbai Network inside your hardhat.config.js networks : { mumbai : { url : ` ${ process . env . ALCHEMY_MUMBAI_URL } ` , accounts : [ `0x ${ process . env . MUMBAI_PRIVATE_KEY } ` ], } ... } Add State.sol contract inside the contracts folder Import the state contract from the existing Mumbai testnet address const contract = await hre . ethers . getContractAt ( \"State\" , \"0x46Fd04eEa588a3EA7e9F055dd691C688c4148ab3\" ); Add inputs from the proof generated in the previous section const id = \"0x00e00c0ee273921f3aa97ba2de5480f140b17e2d35943a8f17a7f45aa04f0000\" const oldState = \"0x0ee273921f3aa97ba2de5480f140b17e2d35943a8f17a7f45aa04fb715a18685\" const newState = \"0x2ba2ba06e0fec5e71fb55019925946590743750a181744fe8eeb8da62e0709db\" const isOldStateGenesis = \"0x0000000000000000000000000000000000000000000000000000000000000001\" const a = [ \"0x2b256e25496ac8584bf5714d347821cf9ac8f2472310306033d1ebd4613d12e9\" , \"0x2cca3d40ba395135a38b4ac8c6f8daf81e968ab7082d26d778a82aad9c39d8e3\" ] const b = [[ \"0x2b92b4fc713b659225bfc2b2560b4a1af7901b2a5ee4a3ed07465a88f70e71b3\" , \"0x241ce1ba397c4e1d65059779cacf30fd8d977ed89e6964fa4aa84daec7965254\" ],[ \"0x27099d3f5cac46fa58c031913c5cd68e24634e9d80281a3d0c0c091bdf574786\" , \"0x08df6f588353293a926660cb1b65a13ad8c5094a42e76dc46d2963ca1cacc096\" ]] const c = [ \"0x0873f0c6ad05f760775b74a8a6e391beb5b5d3a040a3259f6f5c2429b9d37f8d\" , \"0x15ff3cb9c37c9a07b0fdb2f24cad7bf56adc632c625d9d236841676d731f661b\" ] Note: Do not use these same inputs for the next section of the tutorial. I already executed the State Transition using these inputs, so the transaction will fail. Instead, use the inputs that you locally generated. Fetch identity state before state transition let identityState0 = await contract . getState ( id ); // 0 Execute state transition function await contract . transitState ( id , oldState , newState , isOldStateGenesis , a , b , c ); Fetch identity state after state transition let identityState1 = await contract . getState ( id ); // 19736965623849496899943145128310994086117058864343685620577405145725675178459 Congratulations! You have successfully completed the identity state transition. Starting from the identifier, people will be able to track the status of an identity in a timestamped and tamper-proof way. The identifier remains fixed for the entire existence of an identity, while the identity state changes every time an identity gets updated, for example, when issuing or revoking a claim. As we'll see in the next section, every ZK proof generated from an identity will be checked against the identity state published on-chain. It is important to underline that: The mapping that associates an identifier with its current identity state is the only piece of information stored on-chain. Starting from the identifier and the identity state, it is impossible to retrieve any information stored in the identity trees, for example, reading the content of a claim (which is stored off-chain). There is no association between the ECDSA (Elliptical Curve Digital Signature Algorithm) key pair associated with the Ethereum address that executes the State Transition and the Baby Jubjub key pair which is used to control an identity. The executable code can be found here","title":"Verify the Proof On-Chain"},{"location":"getting-started/state-transition/on-chain-state-transition/#verify-the-proof-on-chain","text":"In order to complete the State Transition process it is necessary to verify the proof inside the State.sol contract. The transitState public function of the contract takes the proof generated in the previous section and verifies it on-chain. On verification, the identities mapping associated with the ID that is executing the transition gets updated.","title":"Verify the Proof On-Chain"},{"location":"getting-started/state-transition/on-chain-state-transition/#hardhat","text":"Add Mumbai Network inside your hardhat.config.js networks : { mumbai : { url : ` ${ process . env . ALCHEMY_MUMBAI_URL } ` , accounts : [ `0x ${ process . env . MUMBAI_PRIVATE_KEY } ` ], } ... } Add State.sol contract inside the contracts folder Import the state contract from the existing Mumbai testnet address const contract = await hre . ethers . getContractAt ( \"State\" , \"0x46Fd04eEa588a3EA7e9F055dd691C688c4148ab3\" ); Add inputs from the proof generated in the previous section const id = \"0x00e00c0ee273921f3aa97ba2de5480f140b17e2d35943a8f17a7f45aa04f0000\" const oldState = \"0x0ee273921f3aa97ba2de5480f140b17e2d35943a8f17a7f45aa04fb715a18685\" const newState = \"0x2ba2ba06e0fec5e71fb55019925946590743750a181744fe8eeb8da62e0709db\" const isOldStateGenesis = \"0x0000000000000000000000000000000000000000000000000000000000000001\" const a = [ \"0x2b256e25496ac8584bf5714d347821cf9ac8f2472310306033d1ebd4613d12e9\" , \"0x2cca3d40ba395135a38b4ac8c6f8daf81e968ab7082d26d778a82aad9c39d8e3\" ] const b = [[ \"0x2b92b4fc713b659225bfc2b2560b4a1af7901b2a5ee4a3ed07465a88f70e71b3\" , \"0x241ce1ba397c4e1d65059779cacf30fd8d977ed89e6964fa4aa84daec7965254\" ],[ \"0x27099d3f5cac46fa58c031913c5cd68e24634e9d80281a3d0c0c091bdf574786\" , \"0x08df6f588353293a926660cb1b65a13ad8c5094a42e76dc46d2963ca1cacc096\" ]] const c = [ \"0x0873f0c6ad05f760775b74a8a6e391beb5b5d3a040a3259f6f5c2429b9d37f8d\" , \"0x15ff3cb9c37c9a07b0fdb2f24cad7bf56adc632c625d9d236841676d731f661b\" ] Note: Do not use these same inputs for the next section of the tutorial. I already executed the State Transition using these inputs, so the transaction will fail. Instead, use the inputs that you locally generated. Fetch identity state before state transition let identityState0 = await contract . getState ( id ); // 0 Execute state transition function await contract . transitState ( id , oldState , newState , isOldStateGenesis , a , b , c ); Fetch identity state after state transition let identityState1 = await contract . getState ( id ); // 19736965623849496899943145128310994086117058864343685620577405145725675178459 Congratulations! You have successfully completed the identity state transition. Starting from the identifier, people will be able to track the status of an identity in a timestamped and tamper-proof way. The identifier remains fixed for the entire existence of an identity, while the identity state changes every time an identity gets updated, for example, when issuing or revoking a claim. As we'll see in the next section, every ZK proof generated from an identity will be checked against the identity state published on-chain. It is important to underline that: The mapping that associates an identifier with its current identity state is the only piece of information stored on-chain. Starting from the identifier and the identity state, it is impossible to retrieve any information stored in the identity trees, for example, reading the content of a claim (which is stored off-chain). There is no association between the ECDSA (Elliptical Curve Digital Signature Algorithm) key pair associated with the Ethereum address that executes the State Transition and the Baby Jubjub key pair which is used to control an identity. The executable code can be found here","title":"Hardhat"},{"location":"getting-started/state-transition/state-transition-proof/","text":"Generate Proof for State Transition The output of the previous tutorial was the result of a locally executed computation by the Identity Owner, namely moving from the genesis state to state 1. What if the person that executed the state transition wasn't actually the Identity Owner? What if the key used to sign the message was revoked? To ensure the state transition happens in a trustless way, it must be verified inside a circuit. The State Transition inputs generated earlier will be passed into the State Transition Circuit to generate a proof of the executed state transition. Install Circom and SnarkJS. Clone the repository that contains the compiled circuit git clone https://github.com/iden3/tutorial-examples.git This repository contains the stateTransition compiled circuit after a trusted setup. Create a .json file with the state transition inputs from the previous tutorial For this, create a file named input.json inside the .stateTransition/stateTransition_js and then paste the inputs you generated in the previous tutorial. These inputs will be passed to the circuit and will be used to generate the zk proof. Generate the proof From the compiled-circuits folder run: ./generate.sh stateTransition If everything worked fine, your terminal should display: [ INFO ] snarkJS: OK! Display the proof You should now have 2 new files inside the /stateTransition/stateTransition_js directory, namely proof.json and public.json: proof.json contains the actual proof represented by the three arrays a, b, and c . It contains all the raw data of the proof that the SnarkJS library uses for verification of the proof. public.json is an array of the four elements representing the public inputs of the circuit. These are userID,oldUserState,newUserState,isOldStateGenesis Export the proof in the Solidity calldata. The two files from the above step can also be exported as Solidity calldata in order to execute the verification on-chain. From the stateTransition_js directory run snarkjs generatecall . snarkjs generatecall Here is what the output would look like: [ \"0x2b256e25496ac8584bf5714d347821cf9ac8f2472310306033d1ebd4613d12e9\" , \"0x2cca3d40ba395135a38b4ac8c6f8daf81e968ab7082d26d778a82aad9c39d8e3\" ] , [[ \"0x2b92b4fc713b659225bfc2b2560b4a1af7901b2a5ee4a3ed07465a88f70e71b3\" , \"0x241ce1ba397c4e1d65059779cacf30fd8d977ed89e6964fa4aa84daec7965254\" ] , [ \"0x27099d3f5cac46fa58c031913c5cd68e24634e9d80281a3d0c0c091bdf574786\" , \"0x08df6f588353293a926660cb1b65a13ad8c5094a42e76dc46d2963ca1cacc096\" ]] , [ \"0x0873f0c6ad05f760775b74a8a6e391beb5b5d3a040a3259f6f5c2429b9d37f8d\" , \"0x15ff3cb9c37c9a07b0fdb2f24cad7bf56adc632c625d9d236841676d731f661b\" ] , [ \"0x00e00c0ee273921f3aa97ba2de5480f140b17e2d35943a8f17a7f45aa04f0000\" , \"0x0ee273921f3aa97ba2de5480f140b17e2d35943a8f17a7f45aa04fb715a18685\" , \"0x2ba2ba06e0fec5e71fb55019925946590743750a181744fe8eeb8da62e0709db\" , \"0x0000000000000000000000000000000000000000000000000000000000000001\" ] The Solidity calldata output represents: a[2] , b[2][2] , c[2] , namely the proof public[4] , namely the public inputs of the circuit In the next tutorial, we shall pass this proof to the State.sol smart contract in order to complete the State Transition function.","title":"Generate Proof for State Transition"},{"location":"getting-started/state-transition/state-transition-proof/#generate-proof-for-state-transition","text":"The output of the previous tutorial was the result of a locally executed computation by the Identity Owner, namely moving from the genesis state to state 1. What if the person that executed the state transition wasn't actually the Identity Owner? What if the key used to sign the message was revoked? To ensure the state transition happens in a trustless way, it must be verified inside a circuit. The State Transition inputs generated earlier will be passed into the State Transition Circuit to generate a proof of the executed state transition. Install Circom and SnarkJS. Clone the repository that contains the compiled circuit git clone https://github.com/iden3/tutorial-examples.git This repository contains the stateTransition compiled circuit after a trusted setup. Create a .json file with the state transition inputs from the previous tutorial For this, create a file named input.json inside the .stateTransition/stateTransition_js and then paste the inputs you generated in the previous tutorial. These inputs will be passed to the circuit and will be used to generate the zk proof. Generate the proof From the compiled-circuits folder run: ./generate.sh stateTransition If everything worked fine, your terminal should display: [ INFO ] snarkJS: OK! Display the proof You should now have 2 new files inside the /stateTransition/stateTransition_js directory, namely proof.json and public.json: proof.json contains the actual proof represented by the three arrays a, b, and c . It contains all the raw data of the proof that the SnarkJS library uses for verification of the proof. public.json is an array of the four elements representing the public inputs of the circuit. These are userID,oldUserState,newUserState,isOldStateGenesis Export the proof in the Solidity calldata. The two files from the above step can also be exported as Solidity calldata in order to execute the verification on-chain. From the stateTransition_js directory run snarkjs generatecall . snarkjs generatecall Here is what the output would look like: [ \"0x2b256e25496ac8584bf5714d347821cf9ac8f2472310306033d1ebd4613d12e9\" , \"0x2cca3d40ba395135a38b4ac8c6f8daf81e968ab7082d26d778a82aad9c39d8e3\" ] , [[ \"0x2b92b4fc713b659225bfc2b2560b4a1af7901b2a5ee4a3ed07465a88f70e71b3\" , \"0x241ce1ba397c4e1d65059779cacf30fd8d977ed89e6964fa4aa84daec7965254\" ] , [ \"0x27099d3f5cac46fa58c031913c5cd68e24634e9d80281a3d0c0c091bdf574786\" , \"0x08df6f588353293a926660cb1b65a13ad8c5094a42e76dc46d2963ca1cacc096\" ]] , [ \"0x0873f0c6ad05f760775b74a8a6e391beb5b5d3a040a3259f6f5c2429b9d37f8d\" , \"0x15ff3cb9c37c9a07b0fdb2f24cad7bf56adc632c625d9d236841676d731f661b\" ] , [ \"0x00e00c0ee273921f3aa97ba2de5480f140b17e2d35943a8f17a7f45aa04f0000\" , \"0x0ee273921f3aa97ba2de5480f140b17e2d35943a8f17a7f45aa04fb715a18685\" , \"0x2ba2ba06e0fec5e71fb55019925946590743750a181744fe8eeb8da62e0709db\" , \"0x0000000000000000000000000000000000000000000000000000000000000001\" ] The Solidity calldata output represents: a[2] , b[2][2] , c[2] , namely the proof public[4] , namely the public inputs of the circuit In the next tutorial, we shall pass this proof to the State.sol smart contract in order to complete the State Transition function.","title":"Generate Proof for State Transition"},{"location":"getting-started/state-transition/state-transition/","text":"Intro to State Transtion When an identity adds a new claim to her Claims Tree, the root of the tree and, consequently, the identity state change. The process of moving from one state to another is defined State Transition . The State Transtion is executed inside a circuit. The stateTransition circuit encodes a set of rules that must be respected to complete the state transition such as: The prover is the owner of the identity (checked using a digital signature by the private key corresponding the authClaim ) The authClaim of the prover hasn't been revoked. The identity state gets updated by calling the transitState smart contract function . To call this function, it is necessary to pass in the proof generated previously. On verification, the identities mapping gets updated associating the ID with a new IdS . This tutorial is split in 3 parts: Add Claim to the Claims Tree Generate Proof for State Transition Verify the Proof On-Chain Note: The Identity State Transition happens not only when an identity adds a new claim to the Claims Tree, but also when a claim gets updated or revoked (by adding it to the revocation tree).","title":"Intro to State Transition"},{"location":"getting-started/state-transition/state-transition/#intro-to-state-transtion","text":"When an identity adds a new claim to her Claims Tree, the root of the tree and, consequently, the identity state change. The process of moving from one state to another is defined State Transition . The State Transtion is executed inside a circuit. The stateTransition circuit encodes a set of rules that must be respected to complete the state transition such as: The prover is the owner of the identity (checked using a digital signature by the private key corresponding the authClaim ) The authClaim of the prover hasn't been revoked. The identity state gets updated by calling the transitState smart contract function . To call this function, it is necessary to pass in the proof generated previously. On verification, the identities mapping gets updated associating the ID with a new IdS . This tutorial is split in 3 parts: Add Claim to the Claims Tree Generate Proof for State Transition Verify the Proof On-Chain Note: The Identity State Transition happens not only when an identity adds a new claim to the Claims Tree, but also when a claim gets updated or revoked (by adding it to the revocation tree).","title":"Intro to State Transtion"},{"location":"verify-with-zkp-application-level/demo/","text":"Demo To demo the interaction between a verifier application and a wallet: Setup a verifier Follow the steps outlined in the zk-login-integration to set up a client side verifier If the server is running up locally, use ngrok to serve your application online ngrok http 8080 Add a QR code representing on the client side in order to interact with the identity wallet. Check out this static folder to render the QR code containing the auth Request in a HTML page Download the identity wallet Polygon ID iOS Polygon ID Android Issue claims to your wallet to interact with the server Light Issuer Coming Soon In the meanwhile you can use the claims generated via Polygon Verify and fetch it inside your wallet. Prove your identity with Zero Knowledge Visit <HOSTURL> on your browser From the wallet, scan the QR code associated with the auth request generated by the /api/sign-in endpoint The wallet will receive the auth request, generate the proof locally and send it to the callback url <HOSTURL>/api/callback in a post request. The server will verify the proof to authenticate the user.","title":"Demo"},{"location":"verify-with-zkp-application-level/demo/#demo","text":"To demo the interaction between a verifier application and a wallet: Setup a verifier Follow the steps outlined in the zk-login-integration to set up a client side verifier If the server is running up locally, use ngrok to serve your application online ngrok http 8080 Add a QR code representing on the client side in order to interact with the identity wallet. Check out this static folder to render the QR code containing the auth Request in a HTML page Download the identity wallet Polygon ID iOS Polygon ID Android Issue claims to your wallet to interact with the server Light Issuer Coming Soon In the meanwhile you can use the claims generated via Polygon Verify and fetch it inside your wallet. Prove your identity with Zero Knowledge Visit <HOSTURL> on your browser From the wallet, scan the QR code associated with the auth request generated by the /api/sign-in endpoint The wallet will receive the auth request, generate the proof locally and send it to the callback url <HOSTURL>/api/callback in a post request. The server will verify the proof to authenticate the user.","title":"Demo"},{"location":"verify-with-zkp-application-level/intro/","text":"Introduction You should now be able to setup an issuer, issue claims to yourself and/or other identities and publish them. Now it comes the cool part: being able to verify Claims with Zero Knowledge . Bob can verify that Alice is over 18 without having to access Alice's date of birth In this example: Alice holds a Claim that certifies her date of birth Bob designs a Query \"You must be over 18\" Alice generates a ZK Proof starting from her Claim and Bob's Query Bob verifies Alice's proof and provides access rights Both Claim and Query are broad and customizable data primitives allowing to create any type of identity based verification. The claims associated to an identity are resuable across platforms so any integrator can leverage existing claims and create customized queries. For example exchanges that require KYC claim or DAOs that require proof-of-personhood claim. This section illustrates a set of simple APIs to integrate Iden3 ZK login inside your application for user authentication, abstracting away all the complexity involved with ZK proofs. In particular: ZKLogin workflow , to understand the user workflow ZKLogin integration , to integrate it in your platform with a few lines of code Demo , to demo it JSON Web ZeroKnowledge - JWZ , to understand the core primitive of web2 ZK-based communication Query Language , to design customized queries The tutorial is designed to integrate ZKP verification on the web client side. The user interacting with the client must have the identity wallet app ( Polygon ID iOS , Polygon ID Android or any compatible wallet) installed: Libraries The authentication flow can be implemented either in GoLang or Javascript Go Iden3 Authentication Library JS Iden3 Authentication Library","title":"Introduction"},{"location":"verify-with-zkp-application-level/intro/#introduction","text":"You should now be able to setup an issuer, issue claims to yourself and/or other identities and publish them. Now it comes the cool part: being able to verify Claims with Zero Knowledge . Bob can verify that Alice is over 18 without having to access Alice's date of birth In this example: Alice holds a Claim that certifies her date of birth Bob designs a Query \"You must be over 18\" Alice generates a ZK Proof starting from her Claim and Bob's Query Bob verifies Alice's proof and provides access rights Both Claim and Query are broad and customizable data primitives allowing to create any type of identity based verification. The claims associated to an identity are resuable across platforms so any integrator can leverage existing claims and create customized queries. For example exchanges that require KYC claim or DAOs that require proof-of-personhood claim. This section illustrates a set of simple APIs to integrate Iden3 ZK login inside your application for user authentication, abstracting away all the complexity involved with ZK proofs. In particular: ZKLogin workflow , to understand the user workflow ZKLogin integration , to integrate it in your platform with a few lines of code Demo , to demo it JSON Web ZeroKnowledge - JWZ , to understand the core primitive of web2 ZK-based communication Query Language , to design customized queries The tutorial is designed to integrate ZKP verification on the web client side. The user interacting with the client must have the identity wallet app ( Polygon ID iOS , Polygon ID Android or any compatible wallet) installed:","title":"Introduction"},{"location":"verify-with-zkp-application-level/intro/#libraries","text":"The authentication flow can be implemented either in GoLang or Javascript Go Iden3 Authentication Library JS Iden3 Authentication Library","title":"Libraries"},{"location":"verify-with-zkp-application-level/jwz/","text":"JWZ - JSON Web Zero Knowledge JSON Web Zero-knowledge (JWZ) is an open standard for representing messages proven with zero-knowledge technology. In Iden3 Protocol, JWZ is the core primitive to manage communications between different parties. A JWZ expands the signature schema of the popular JWT standard . Any message can be packed inside a JWZ while the signature guarantees data integrity and provenance of the message, providing helpful metadata among the message. JWZ This is an example of a JWZ generated by an identity wallet as a response to the auth request generated in the ZK-login Integration Demo . JWZ consists of three parts separated by dots (.), which are: Header Payload message Signature eyJhbGciOiJncm90aDE2IiwiY2lyY3VpdElkIjoiYXV0aCIsImNyaXQiOlsiY2lyY3VpdElkIl0sInR5cCI6ImFwcGxpY2F0aW9uL2lkZW4zLXprcC1qc29uIn0.eyJpZCI6IjZhOWU4MDlhLTAwNzktNDI2OS1hMzA5LTdlYmIyZDE2YTIzYyIsInR5cCI6ImFwcGxpY2F0aW9uL2lkZW4zY29tbS1wbGFpbi1qc29uIiwidHlwZSI6Imh0dHBzOi8vaWRlbjMtY29tbXVuaWNhdGlvbi5pby9hdXRob3JpemF0aW9uLzEuMC9yZXNwb25zZSIsInRoaWQiOiI3ZjM4YTE5My0wOTE4LTRhNDgtOWZhYy0zNmFkZmRiOGI1NDIiLCJmcm9tIjoiMTFCckE5cmhiWEJwWEMyS0tUOTlzNTEyc1htYnlWa3V1MjFuWWU0NHFiIiwidG8iOiIxMTI1R0pxZ3c2WUVzS0Z3ajYzR1k4N01NeFBMOWt3REt4UFVpd01MTloiLCJib2R5Ijp7Im1lc3NhZ2UiOiJtZXNzYWdlIHRvIHNpZ24iLCJzY29wZSI6W3siaWQiOjEsImNpcmN1aXRfaWQiOiJjcmVkZW50aWFsQXRvbWljUXVlcnlTaWciLCJwcm9vZiI6eyJwaV9hIjpbIjIzNDkzNTkyMTg4NjIyMTAxOTk4NTgzMTc3MTE2OTMwMDAyNTg2MzIwMjQxMzk4MjE2NTQ0MTk1Nzg4MTg3MTc0MDk5MTExMDMzNDUiLCI5NzgzNjU5NTQyNzgxOTM1OTQ3NTk0MjcxMTk1ODA5OTk3MzcyOTM4NDk5NzQ1MDM3NzI1MjMxNDgwNjE3NzgyODk1MTA4Nzk4NjM4IiwiMSJdLCJwaV9iIjpbWyIyNzIyNTc0ODgxMjgxNTQ1MDgyOTAzNjAyMjIyMDYwOTQ3MjA3OTA0NzcwMjYyMzMwOTM2NTQ3MTQ5NjAzNzAxNzE5MTE1Njc2OTY2IiwiOTEyNTA4MDA3ODY0MzM4OTU0ODIzNzExMjk1NDU2MzAyOTE4NTU1NjI4NjMwMTg5MDM5ODc2MzUxNDUyMzExOTQ4MDAzNjU3MDMxMSJdLFsiMTM2NDAzMDk4MDA3ODQwNTUyMDI2OTYwOTk3ODI5MTk3OTg1NjE5ODU0OTA3MDI2NjM1MzgxNjgyMTkxMTUxNzU4NDk5OTk5MTkzNzMiLCIxMDM2MzMyMDQ2MjI5NjAwMTc5ODU2MDUwNTc4MTM5NzM3MzAzMjk0MzI5NzU3MTU4OTY3NzA3NjQyMDU1MDg3Nzg2MzYzNDQ3NzY1MiJdLFsiMSIsIjAiXV0sInBpX2MiOlsiMTk0NjgyODk1MDc0Mjg1MTUyOTcwNTU0MjM1MjEzNjkwNTg1MTQ4NTgyMjgxMTE0MDA2MTkzOTcwODkxODQ3OTg3OTU1MDIwMzA0MzQiLCI2MTg0NTc0NjY3ODYyNjg5OTQ2Mjk0MzgwMDAxMDk5NjgzOTI3NTYwMzk0ODE4MjM2Mzc5MzEzNTgxMTI2NjIwMjYyMDUxMzI1OTkwIiwiMSJdLCJjdXJ2ZSI6bnVsbCwicHJvdG9jb2wiOiJncm90aDE2In0sInB1Yl9zaWduYWxzIjpbIjE2NTE2MTkxMjIyMjc2NDg0NzQzMDE5NDIyMDM5ODIxMTA4ODcwNjI3MjcxNTgwNzIwMzI5NTk5MzQwNzg5MjQxMjcwMDE1Mjg2Mjg4IiwiMzc4MTg4ODY2MjM0Njc5Nzk0MTcxNjY1Njk4NTU0NjQ4OTEyMjYyNTUwMTQzODY2NTUyMzY5MTQ3NDY4MTY2OTAyMzc4NzkwOTEyIiwiMTI5NzU3NjYzNTEzNTMyMjM1ODA4MDk5MDYxNzAwMDY0NjYwNzAzOTQ3NDE3ODM5MjUzOTI2OTE1MTU5NDc2NTI2NDc1MTY3NDYxODIiLCIxIiwiNTMxMDMwMjA4MzM5MTc0NDM5OTUxMDAxNTExODU5MjI4OTU5MTYyMTkzNDcwNzY5NTM2MDMwMzIxODI4MTIyMjI2MDczOTI3NjgiLCIxNTU4NjUxOTcwMDcwNTkxMjc3OTE3MzU3MzgzMDEyMTYyMzU2NTg4OTcyODE3MjAzOTE5NTk2ODQyNTU3MTA5MTAxMzc0NTY5ODg2NiIsIjE2NTUzMDQwNDkiLCIyMTA0NTk1Nzk4NTkwNTgxMzU0MDQ3NzAwNDM3ODgwMjgyOTIzOTgiLCIyIiwiMiIsIjIwMDAwMTAxIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIl19XX19.eyJwcm9vZiI6eyJwaV9hIjpbIjIxNzkwODAzMjI2NDE1NDQzNTg3NTAzMjk4NzY5MjQwODA5MDYzMTE5MTgzMjY4MzMzODU1NzM4MTI4NDU4MDA2NjI1MTM4NzM4MTIwIiwiMTY2OTg2MjAyMzY2MjE3Mjk1MjM4NjUzNzc5MTkzODMyNjM2MDc3MzQ4OTU0NjQ5MDEwNDY2ODI3Mjc0NDE4NDczODcwNTM0NTIyMjMiLCIxIl0sInBpX2IiOltbIjQ1MzU3NDg4NDc0NTE2MjA3MjcwMzA4NTA5NjgzNDgyODM1MzMyMjE4OTIxNTY0Nzk3ODQ0Nzg1NTA1NzYyOTE5Njc4NzAxNDYzNjkiLCI5NzM4MjczODE4NDA0ODMyNzYzNzk3NzU1NzI5MzY0NDY5MzU5MDMyNTg5Mzc0MjU3MDc3OTg3MzE0ODQwMDc0MjkxNzAwMDQ2NjYzIl0sWyI4MDQyMTUzMDUwOTA0ODE0NzUzNTI0Mjk5OTM2OTczNjg4MDMzNDg0NzU5MDk5MDAwNjE2OTUyNTk3MjQwOTI0MDIwMTYxNTIyOTAzIiwiMTIxODAwMzE1NDk1NzkwMzU5OTI1MTU5NDI5MzQ1MDk3MjgwNzQ0NDYwMzU5MDU2MDkxNzA2MDAxMTE3NDM4MDgxMDM2MzE1MzAxNiJdLFsiMSIsIjAiXV0sInBpX2MiOlsiMTA3OTQ0MzMyNTU0NTc0MDU0NTcxNTA5NjUxMDgyNDI0MTg2NzkyNzEyNjQyOTExNDIwNzkzNTgzODc3OTUwNTA4NzE4MTg0MDU4NjIiLCIyMDk0MjA1NTIxMTA2NDMyNTg2NjU4NjUxMDAwNzU2NjgwMjcyNjg3NjgxNjIzNzEyMTgyODM2MDQ4Mzk0ODc0MTIyMzk5MTkzNTE5OCIsIjEiXSwicHJvdG9jb2wiOiJncm90aDE2In0sInB1Yl9zaWduYWxzIjpbIjE4MDE2NDYyOTI3NzgzNjAwNDgyODIyNjgxNTQ4OTg1MDYxMDk5MzY5MTQ0MjczMzE1OTA1MDU1Mzc4NDUxMjg5NzM1MjY0MTI3NTMyIiwiMTI5NzU3NjYzNTEzNTMyMjM1ODA4MDk5MDYxNzAwMDY0NjYwNzAzOTQ3NDE3ODM5MjUzOTI2OTE1MTU5NDc2NTI2NDc1MTY3NDYxODIiLCIzNzgxODg4NjYyMzQ2Nzk3OTQxNzE2NjU2OTg1NTQ2NDg5MTIyNjI1NTAxNDM4NjY1NTIzNjkxNDc0NjgxNjY5MDIzNzg3OTA5MTIiXX0 Each part of the token can be parse into human-readable string by base 64 decoding . Header Defines the feature of the token. { \"alg\" : \"groth16\" , \"circuitId\" : \"auth\" , \"crit\" :[ \"circuitId\" ], \"typ\" : \"application/iden3-zkp-json\" } alg - is a zero-knowledge algorithm that is used for proof generation. circuitId - is a circuit that is used for proof generation. For authentication - auth circuit must be used. crit describes the list of header keys that the verifier must support. typ is the media type of the message. In our case, it\u2019s the protocol type of packed message application/iden3-zkp-json Payload Message Contains the message that wants to be shared with another party In this example the message is the proof related to the query analysed previously. However, any type of message can be included in the payload. { \"id\" : \"6a9e809a-0079-4269-a309-7ebb2d16a23c\" , \"typ\" : \"application/iden3comm-plain-json\" , \"type\" : \"https://iden3-communication.io/authorization/1.0/response\" , \"thid\" : \"7f38a193-0918-4a48-9fac-36adfdb8b542\" , \"from\" : \"11BrA9rhbXBpXC2KKT99s512sXmbyVkuu21nYe44qb\" , \"to\" : \"1125GJqgw6YEsKFwj63GY87MMxPL9kwDKxPUiwMLNZ\" , \"body\" : { \"message\" : \"message to sign\" , \"scope\" :[ { \"id\" : 1 , \"circuit_id\" : \"credentialAtomicQuerySig\" , \"proof\" : { \"pi_a\" :[ \"2349359218862210199858317711693000258632024139821654419578818717409911103345\" , \"9783659542781935947594271195809997372938499745037725231480617782895108798638\" , \"1\" ], \"pi_b\" :[[ \"2722574881281545082903602222060947207904770262330936547149603701719115676966\" , \"9125080078643389548237112954563029185556286301890398763514523119480036570311\" ],[ \"13640309800784055202696099782919798561985490702663538168219115175849999919373\" , \"10363320462296001798560505781397373032943297571589677076420550877863634477652\" ],[ \"1\" , \"0\" ]], \"pi_c\" :[ \"19468289507428515297055423521369058514858228111400619397089184798795502030434\" , \"6184574667862689946294380001099683927560394818236379313581126620262051325990\" , \"1\" ], \"curve\" : null , \"protocol\" : \"groth16\" }, \"pub_signals\" :[ \"16516191222276484743019422039821108870627271580720329599340789241270015286288\" , \"378188866234679794171665698554648912262550143866552369147468166902378790912\" , \"12975766351353223580809906170006466070394741783925392691515947652647516746182\" , \"1\" , \"53103020833917443995100151185922895916219347076953603032182812222607392768\" , \"15586519700705912779173573830121623565889728172039195968425571091013745698866\" , \"1655304049\" , \"210459579859058135404770043788028292398\" , \"2\" , \"2\" , \"20000101\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" ] } ] } } Signature It represents a ZK authentication proof based on the auth circuit { \"proof\" : { \"pi_a\" :[ \"21790803226415443587503298769240809063119183268333855738128458006625138738120\" , \"16698620236621729523865377919383263607734895464901046682727441847387053452223\" , \"1\" ], \"pi_b\" :[[ \"4535748847451620727030850968348283533221892156479784478550576291967870146369\" , \"9738273818404832763797755729364469359032589374257077987314840074291700046663\" ],[ \"8042153050904814753524299936973688033484759099000616952597240924020161522903\" , \"1218003154957903599251594293450972807444603590560917060011174380810363153016\" ],[ \"1\" , \"0\" ]], \"pi_c\" :[ \"10794433255457405457150965108242418679271264291142079358387795050871818405862\" , \"20942055211064325866586510007566802726876816237121828360483948741223991935198\" , \"1\" ], \"protocol\" : \"groth16\" }, \"pub_signals\" :[ \"18016462927783600482822681548985061099369144273315905055378451289735264127532\" , \"12975766351353223580809906170006466070394741783925392691515947652647516746182\" , \"378188866234679794171665698554648912262550143866552369147468166902378790912\" ] } Difference between JWT and JWZ JWT relies on digital signatures for secure transmission of information. In particular \"JWTs can be signed using a secret (with the HMAC algorithm) or a public/private key pair using RSA or ECDSA\" . ( JWT.io ). In JWZ, this signature is performed with Zero Knowledge. In particular: The header and the payload gets hashed together using the poseidon hash The JWZ initiator signs the hashed content using his/her private key The JWZ creator generates a proof using the authorization circuit to demonstrate that his/her identity signed the content The proof gets included in the zero knowledge proof of the JWZ together with the public inputs used inside the circuit to generate the proof Any third party that access the JWZ can verify the proof to check if the information contained in the payload actually originated from that identity and hasn't tampered with. Usage JWZ represents the main instrument to communicate securely between parties off-chain. This data primitive integrates seamlessy withing web2 architectures for authentication purposes. Here we used the JWZ to manage the communication between user and verifier. A JWZ can also be used in the communiciation between user and issuer for user to prove their identity in order to fetch the claims associated with their identity. For web3/smart contract based authentication the data must be passed in a different format. This will be the subject of the next section of the tutorial. Libraries js-jwz for JavaScript implementation go-jwz for Go implementation","title":"JWZ"},{"location":"verify-with-zkp-application-level/jwz/#jwz-json-web-zero-knowledge","text":"JSON Web Zero-knowledge (JWZ) is an open standard for representing messages proven with zero-knowledge technology. In Iden3 Protocol, JWZ is the core primitive to manage communications between different parties. A JWZ expands the signature schema of the popular JWT standard . Any message can be packed inside a JWZ while the signature guarantees data integrity and provenance of the message, providing helpful metadata among the message. JWZ This is an example of a JWZ generated by an identity wallet as a response to the auth request generated in the ZK-login Integration Demo . JWZ consists of three parts separated by dots (.), which are: Header Payload message Signature eyJhbGciOiJncm90aDE2IiwiY2lyY3VpdElkIjoiYXV0aCIsImNyaXQiOlsiY2lyY3VpdElkIl0sInR5cCI6ImFwcGxpY2F0aW9uL2lkZW4zLXprcC1qc29uIn0.eyJpZCI6IjZhOWU4MDlhLTAwNzktNDI2OS1hMzA5LTdlYmIyZDE2YTIzYyIsInR5cCI6ImFwcGxpY2F0aW9uL2lkZW4zY29tbS1wbGFpbi1qc29uIiwidHlwZSI6Imh0dHBzOi8vaWRlbjMtY29tbXVuaWNhdGlvbi5pby9hdXRob3JpemF0aW9uLzEuMC9yZXNwb25zZSIsInRoaWQiOiI3ZjM4YTE5My0wOTE4LTRhNDgtOWZhYy0zNmFkZmRiOGI1NDIiLCJmcm9tIjoiMTFCckE5cmhiWEJwWEMyS0tUOTlzNTEyc1htYnlWa3V1MjFuWWU0NHFiIiwidG8iOiIxMTI1R0pxZ3c2WUVzS0Z3ajYzR1k4N01NeFBMOWt3REt4UFVpd01MTloiLCJib2R5Ijp7Im1lc3NhZ2UiOiJtZXNzYWdlIHRvIHNpZ24iLCJzY29wZSI6W3siaWQiOjEsImNpcmN1aXRfaWQiOiJjcmVkZW50aWFsQXRvbWljUXVlcnlTaWciLCJwcm9vZiI6eyJwaV9hIjpbIjIzNDkzNTkyMTg4NjIyMTAxOTk4NTgzMTc3MTE2OTMwMDAyNTg2MzIwMjQxMzk4MjE2NTQ0MTk1Nzg4MTg3MTc0MDk5MTExMDMzNDUiLCI5NzgzNjU5NTQyNzgxOTM1OTQ3NTk0MjcxMTk1ODA5OTk3MzcyOTM4NDk5NzQ1MDM3NzI1MjMxNDgwNjE3NzgyODk1MTA4Nzk4NjM4IiwiMSJdLCJwaV9iIjpbWyIyNzIyNTc0ODgxMjgxNTQ1MDgyOTAzNjAyMjIyMDYwOTQ3MjA3OTA0NzcwMjYyMzMwOTM2NTQ3MTQ5NjAzNzAxNzE5MTE1Njc2OTY2IiwiOTEyNTA4MDA3ODY0MzM4OTU0ODIzNzExMjk1NDU2MzAyOTE4NTU1NjI4NjMwMTg5MDM5ODc2MzUxNDUyMzExOTQ4MDAzNjU3MDMxMSJdLFsiMTM2NDAzMDk4MDA3ODQwNTUyMDI2OTYwOTk3ODI5MTk3OTg1NjE5ODU0OTA3MDI2NjM1MzgxNjgyMTkxMTUxNzU4NDk5OTk5MTkzNzMiLCIxMDM2MzMyMDQ2MjI5NjAwMTc5ODU2MDUwNTc4MTM5NzM3MzAzMjk0MzI5NzU3MTU4OTY3NzA3NjQyMDU1MDg3Nzg2MzYzNDQ3NzY1MiJdLFsiMSIsIjAiXV0sInBpX2MiOlsiMTk0NjgyODk1MDc0Mjg1MTUyOTcwNTU0MjM1MjEzNjkwNTg1MTQ4NTgyMjgxMTE0MDA2MTkzOTcwODkxODQ3OTg3OTU1MDIwMzA0MzQiLCI2MTg0NTc0NjY3ODYyNjg5OTQ2Mjk0MzgwMDAxMDk5NjgzOTI3NTYwMzk0ODE4MjM2Mzc5MzEzNTgxMTI2NjIwMjYyMDUxMzI1OTkwIiwiMSJdLCJjdXJ2ZSI6bnVsbCwicHJvdG9jb2wiOiJncm90aDE2In0sInB1Yl9zaWduYWxzIjpbIjE2NTE2MTkxMjIyMjc2NDg0NzQzMDE5NDIyMDM5ODIxMTA4ODcwNjI3MjcxNTgwNzIwMzI5NTk5MzQwNzg5MjQxMjcwMDE1Mjg2Mjg4IiwiMzc4MTg4ODY2MjM0Njc5Nzk0MTcxNjY1Njk4NTU0NjQ4OTEyMjYyNTUwMTQzODY2NTUyMzY5MTQ3NDY4MTY2OTAyMzc4NzkwOTEyIiwiMTI5NzU3NjYzNTEzNTMyMjM1ODA4MDk5MDYxNzAwMDY0NjYwNzAzOTQ3NDE3ODM5MjUzOTI2OTE1MTU5NDc2NTI2NDc1MTY3NDYxODIiLCIxIiwiNTMxMDMwMjA4MzM5MTc0NDM5OTUxMDAxNTExODU5MjI4OTU5MTYyMTkzNDcwNzY5NTM2MDMwMzIxODI4MTIyMjI2MDczOTI3NjgiLCIxNTU4NjUxOTcwMDcwNTkxMjc3OTE3MzU3MzgzMDEyMTYyMzU2NTg4OTcyODE3MjAzOTE5NTk2ODQyNTU3MTA5MTAxMzc0NTY5ODg2NiIsIjE2NTUzMDQwNDkiLCIyMTA0NTk1Nzk4NTkwNTgxMzU0MDQ3NzAwNDM3ODgwMjgyOTIzOTgiLCIyIiwiMiIsIjIwMDAwMTAxIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIl19XX19.eyJwcm9vZiI6eyJwaV9hIjpbIjIxNzkwODAzMjI2NDE1NDQzNTg3NTAzMjk4NzY5MjQwODA5MDYzMTE5MTgzMjY4MzMzODU1NzM4MTI4NDU4MDA2NjI1MTM4NzM4MTIwIiwiMTY2OTg2MjAyMzY2MjE3Mjk1MjM4NjUzNzc5MTkzODMyNjM2MDc3MzQ4OTU0NjQ5MDEwNDY2ODI3Mjc0NDE4NDczODcwNTM0NTIyMjMiLCIxIl0sInBpX2IiOltbIjQ1MzU3NDg4NDc0NTE2MjA3MjcwMzA4NTA5NjgzNDgyODM1MzMyMjE4OTIxNTY0Nzk3ODQ0Nzg1NTA1NzYyOTE5Njc4NzAxNDYzNjkiLCI5NzM4MjczODE4NDA0ODMyNzYzNzk3NzU1NzI5MzY0NDY5MzU5MDMyNTg5Mzc0MjU3MDc3OTg3MzE0ODQwMDc0MjkxNzAwMDQ2NjYzIl0sWyI4MDQyMTUzMDUwOTA0ODE0NzUzNTI0Mjk5OTM2OTczNjg4MDMzNDg0NzU5MDk5MDAwNjE2OTUyNTk3MjQwOTI0MDIwMTYxNTIyOTAzIiwiMTIxODAwMzE1NDk1NzkwMzU5OTI1MTU5NDI5MzQ1MDk3MjgwNzQ0NDYwMzU5MDU2MDkxNzA2MDAxMTE3NDM4MDgxMDM2MzE1MzAxNiJdLFsiMSIsIjAiXV0sInBpX2MiOlsiMTA3OTQ0MzMyNTU0NTc0MDU0NTcxNTA5NjUxMDgyNDI0MTg2NzkyNzEyNjQyOTExNDIwNzkzNTgzODc3OTUwNTA4NzE4MTg0MDU4NjIiLCIyMDk0MjA1NTIxMTA2NDMyNTg2NjU4NjUxMDAwNzU2NjgwMjcyNjg3NjgxNjIzNzEyMTgyODM2MDQ4Mzk0ODc0MTIyMzk5MTkzNTE5OCIsIjEiXSwicHJvdG9jb2wiOiJncm90aDE2In0sInB1Yl9zaWduYWxzIjpbIjE4MDE2NDYyOTI3NzgzNjAwNDgyODIyNjgxNTQ4OTg1MDYxMDk5MzY5MTQ0MjczMzE1OTA1MDU1Mzc4NDUxMjg5NzM1MjY0MTI3NTMyIiwiMTI5NzU3NjYzNTEzNTMyMjM1ODA4MDk5MDYxNzAwMDY0NjYwNzAzOTQ3NDE3ODM5MjUzOTI2OTE1MTU5NDc2NTI2NDc1MTY3NDYxODIiLCIzNzgxODg4NjYyMzQ2Nzk3OTQxNzE2NjU2OTg1NTQ2NDg5MTIyNjI1NTAxNDM4NjY1NTIzNjkxNDc0NjgxNjY5MDIzNzg3OTA5MTIiXX0 Each part of the token can be parse into human-readable string by base 64 decoding .","title":"JWZ - JSON Web Zero Knowledge"},{"location":"verify-with-zkp-application-level/jwz/#header","text":"Defines the feature of the token. { \"alg\" : \"groth16\" , \"circuitId\" : \"auth\" , \"crit\" :[ \"circuitId\" ], \"typ\" : \"application/iden3-zkp-json\" } alg - is a zero-knowledge algorithm that is used for proof generation. circuitId - is a circuit that is used for proof generation. For authentication - auth circuit must be used. crit describes the list of header keys that the verifier must support. typ is the media type of the message. In our case, it\u2019s the protocol type of packed message application/iden3-zkp-json","title":"Header"},{"location":"verify-with-zkp-application-level/jwz/#payload-message","text":"Contains the message that wants to be shared with another party In this example the message is the proof related to the query analysed previously. However, any type of message can be included in the payload. { \"id\" : \"6a9e809a-0079-4269-a309-7ebb2d16a23c\" , \"typ\" : \"application/iden3comm-plain-json\" , \"type\" : \"https://iden3-communication.io/authorization/1.0/response\" , \"thid\" : \"7f38a193-0918-4a48-9fac-36adfdb8b542\" , \"from\" : \"11BrA9rhbXBpXC2KKT99s512sXmbyVkuu21nYe44qb\" , \"to\" : \"1125GJqgw6YEsKFwj63GY87MMxPL9kwDKxPUiwMLNZ\" , \"body\" : { \"message\" : \"message to sign\" , \"scope\" :[ { \"id\" : 1 , \"circuit_id\" : \"credentialAtomicQuerySig\" , \"proof\" : { \"pi_a\" :[ \"2349359218862210199858317711693000258632024139821654419578818717409911103345\" , \"9783659542781935947594271195809997372938499745037725231480617782895108798638\" , \"1\" ], \"pi_b\" :[[ \"2722574881281545082903602222060947207904770262330936547149603701719115676966\" , \"9125080078643389548237112954563029185556286301890398763514523119480036570311\" ],[ \"13640309800784055202696099782919798561985490702663538168219115175849999919373\" , \"10363320462296001798560505781397373032943297571589677076420550877863634477652\" ],[ \"1\" , \"0\" ]], \"pi_c\" :[ \"19468289507428515297055423521369058514858228111400619397089184798795502030434\" , \"6184574667862689946294380001099683927560394818236379313581126620262051325990\" , \"1\" ], \"curve\" : null , \"protocol\" : \"groth16\" }, \"pub_signals\" :[ \"16516191222276484743019422039821108870627271580720329599340789241270015286288\" , \"378188866234679794171665698554648912262550143866552369147468166902378790912\" , \"12975766351353223580809906170006466070394741783925392691515947652647516746182\" , \"1\" , \"53103020833917443995100151185922895916219347076953603032182812222607392768\" , \"15586519700705912779173573830121623565889728172039195968425571091013745698866\" , \"1655304049\" , \"210459579859058135404770043788028292398\" , \"2\" , \"2\" , \"20000101\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" , \"0\" ] } ] } }","title":"Payload Message"},{"location":"verify-with-zkp-application-level/jwz/#signature","text":"It represents a ZK authentication proof based on the auth circuit { \"proof\" : { \"pi_a\" :[ \"21790803226415443587503298769240809063119183268333855738128458006625138738120\" , \"16698620236621729523865377919383263607734895464901046682727441847387053452223\" , \"1\" ], \"pi_b\" :[[ \"4535748847451620727030850968348283533221892156479784478550576291967870146369\" , \"9738273818404832763797755729364469359032589374257077987314840074291700046663\" ],[ \"8042153050904814753524299936973688033484759099000616952597240924020161522903\" , \"1218003154957903599251594293450972807444603590560917060011174380810363153016\" ],[ \"1\" , \"0\" ]], \"pi_c\" :[ \"10794433255457405457150965108242418679271264291142079358387795050871818405862\" , \"20942055211064325866586510007566802726876816237121828360483948741223991935198\" , \"1\" ], \"protocol\" : \"groth16\" }, \"pub_signals\" :[ \"18016462927783600482822681548985061099369144273315905055378451289735264127532\" , \"12975766351353223580809906170006466070394741783925392691515947652647516746182\" , \"378188866234679794171665698554648912262550143866552369147468166902378790912\" ] }","title":"Signature"},{"location":"verify-with-zkp-application-level/jwz/#difference-between-jwt-and-jwz","text":"JWT relies on digital signatures for secure transmission of information. In particular \"JWTs can be signed using a secret (with the HMAC algorithm) or a public/private key pair using RSA or ECDSA\" . ( JWT.io ). In JWZ, this signature is performed with Zero Knowledge. In particular: The header and the payload gets hashed together using the poseidon hash The JWZ initiator signs the hashed content using his/her private key The JWZ creator generates a proof using the authorization circuit to demonstrate that his/her identity signed the content The proof gets included in the zero knowledge proof of the JWZ together with the public inputs used inside the circuit to generate the proof Any third party that access the JWZ can verify the proof to check if the information contained in the payload actually originated from that identity and hasn't tampered with.","title":"Difference between JWT and JWZ"},{"location":"verify-with-zkp-application-level/jwz/#usage","text":"JWZ represents the main instrument to communicate securely between parties off-chain. This data primitive integrates seamlessy withing web2 architectures for authentication purposes. Here we used the JWZ to manage the communication between user and verifier. A JWZ can also be used in the communiciation between user and issuer for user to prove their identity in order to fetch the claims associated with their identity. For web3/smart contract based authentication the data must be passed in a different format. This will be the subject of the next section of the tutorial.","title":"Usage"},{"location":"verify-with-zkp-application-level/jwz/#libraries","text":"js-jwz for JavaScript implementation go-jwz for Go implementation","title":"Libraries"},{"location":"verify-with-zkp-application-level/query-language/","text":"Query Language The Atomic Query Signature Circuit and Atomic Query MTP circuits have been designed as generic circuits to do ZK verification based on user's claims. The Query language sits on top of these circuits to provide a way for developers to design customised requirements based on someone's claims. Platforms can implement queries for user authentication/verification in a flexible way using the Query Language operators, for example: Must be an admin inside PolygonDAO to vote for a specific proposal - equals Must have been born before 2000-01-01 to access an adult content website - less-than Must have a monthly salary greater than $1000 to get a loan - greater-than Must have one game item across a list of items to enter a tournament - \u00ecn Must not be resident of one country inside a list of countries to operate on an exchange - not-in Starting from the proof generated by the user, the verifier is easily able to check if the query is satisfied or not. The verifier doesn't get access to any user's data . As long as the user has been issued a claim that contain certain information, the verifier can design a specific query related to the claim based on these 5 operators. The data structure of the claim described below is simplified. More details about the actual claim strucutre can be found here Equals Claim Polygo n DAOMember { \"role\" : \"5\" // 5 corresponds to Dao Admin. Each role has a code associated } Query const proofRequest : protocol.ZKPRequest = { id : 1 , circuit_id : 'credentialAtomicQuerySig' , rules : { query : { allowedIssuers : [ '11A4eeoCN7Xdy5FZSd3BDxUS9yeA7FGGCCmpKPNhNP' ], // ID of the trusted issuer schema : { type : 'PolygonDAOMember' , url : 'https://schema.polygonid.com/jsonld/dao.json-ld' , }, req : { role : { $eq : 5 , // the role must be 5 = Group Admin }, }, }, }, }; Less-than Claim AgeCrede nt ial { \"birthDay\" : \"19701230\" //yymmdd } Query const proofRequest : protocol.ZKPRequest = { id : 1 , circuit_id : 'credentialAtomicQuerySig' , rules : { query : { allowedIssuers : [ '113T3p9mwkNbRwsREgBwdjMdNJehAW5p6HcJSBpPjQ' , '111DLXZwaj5Ag4hBneVgfb8FAy5EiyxjSkayVpqKj' ], // ID of the trusted issuers schema : { type : 'AgeCredential' , url : 'https://schema.polygonid.com/jsonld/kyc.json-ld' , }, req : { birthDay : { $lt : 20000101 , // birthDay field less then 2000/01/01 }, }, }, }, }; Greater-than Claim EmployeeDa ta { \"monthlySalary\" : \"1650\" , //denominated in $$ \"employedSince\" : \"20151230\" } Query const proofRequest : protocol.ZKPRequest = { id : 1 , circuit_id : 'credentialAtomicQuerySig' , rules : { query : { allowedIssuers : [ '*' ], schema : { type : 'EmployeeData' , url : 'https://schema.com/...employeedata' , }, req : { monthlySalary : { $gt : 1000 , // monthlySalary must be over $1000 }, }, }, }, }; Schema type yet to be defined In Claim UserGameI te ms { \"item\" : \"52\" , // 52 identifies a specific in-game item } Query const proofRequest : protocol.ZKPRequest = { id : 1 , circuit_id : 'credentialAtomicQuerySig' , rules : { query : { allowedIssuers : [ '*' ], schema : { type : 'UserGameItems' , url : 'https://schema.com/...usergameitems' , }, req : { item : { $in : [ 47 , 52 , 112 , 145 ], // accept users that have an item included in the list }, }, }, }, }; Schema type yet to be defined Not-in Claim Cou ntr yO f Reside n ceCrede nt ial { \"countryCode\" : \"840\" } Query const proofRequest : protocol.ZKPRequest = { id : 1 , circuit_id : 'credentialAtomicQuerySig' , rules : { query : { allowedIssuers : [ '11BL1tHEwMR1tuCERfnaYbw4m5QPf45PKfFKZTL2Ep' ], // ID of the trusted issuer schema : { type : 'CountryOfResidenceCredential' , url : 'https://schema.polygonid.com/jsonld/kyc.json-ld' , }, req : { countryCode : { $nin : [ 840 , 120 , 340 , 509 ], // accepted any country not in the list }, }, }, }, }; To add a operator-based query inside a proof request is not mandatory. For instance, a platform can just ask the user to have an AgeCredential claim as a way to identity unique humans without any requirements on the date of birth. In that case the veriifer should simply not fill the req field inside the proofRequest","title":"Query"},{"location":"verify-with-zkp-application-level/query-language/#query-language","text":"The Atomic Query Signature Circuit and Atomic Query MTP circuits have been designed as generic circuits to do ZK verification based on user's claims. The Query language sits on top of these circuits to provide a way for developers to design customised requirements based on someone's claims. Platforms can implement queries for user authentication/verification in a flexible way using the Query Language operators, for example: Must be an admin inside PolygonDAO to vote for a specific proposal - equals Must have been born before 2000-01-01 to access an adult content website - less-than Must have a monthly salary greater than $1000 to get a loan - greater-than Must have one game item across a list of items to enter a tournament - \u00ecn Must not be resident of one country inside a list of countries to operate on an exchange - not-in Starting from the proof generated by the user, the verifier is easily able to check if the query is satisfied or not. The verifier doesn't get access to any user's data . As long as the user has been issued a claim that contain certain information, the verifier can design a specific query related to the claim based on these 5 operators. The data structure of the claim described below is simplified. More details about the actual claim strucutre can be found here","title":"Query Language"},{"location":"verify-with-zkp-application-level/query-language/#equals","text":"Claim Polygo n DAOMember { \"role\" : \"5\" // 5 corresponds to Dao Admin. Each role has a code associated } Query const proofRequest : protocol.ZKPRequest = { id : 1 , circuit_id : 'credentialAtomicQuerySig' , rules : { query : { allowedIssuers : [ '11A4eeoCN7Xdy5FZSd3BDxUS9yeA7FGGCCmpKPNhNP' ], // ID of the trusted issuer schema : { type : 'PolygonDAOMember' , url : 'https://schema.polygonid.com/jsonld/dao.json-ld' , }, req : { role : { $eq : 5 , // the role must be 5 = Group Admin }, }, }, }, };","title":"Equals"},{"location":"verify-with-zkp-application-level/query-language/#less-than","text":"Claim AgeCrede nt ial { \"birthDay\" : \"19701230\" //yymmdd } Query const proofRequest : protocol.ZKPRequest = { id : 1 , circuit_id : 'credentialAtomicQuerySig' , rules : { query : { allowedIssuers : [ '113T3p9mwkNbRwsREgBwdjMdNJehAW5p6HcJSBpPjQ' , '111DLXZwaj5Ag4hBneVgfb8FAy5EiyxjSkayVpqKj' ], // ID of the trusted issuers schema : { type : 'AgeCredential' , url : 'https://schema.polygonid.com/jsonld/kyc.json-ld' , }, req : { birthDay : { $lt : 20000101 , // birthDay field less then 2000/01/01 }, }, }, }, };","title":"Less-than"},{"location":"verify-with-zkp-application-level/query-language/#greater-than","text":"Claim EmployeeDa ta { \"monthlySalary\" : \"1650\" , //denominated in $$ \"employedSince\" : \"20151230\" } Query const proofRequest : protocol.ZKPRequest = { id : 1 , circuit_id : 'credentialAtomicQuerySig' , rules : { query : { allowedIssuers : [ '*' ], schema : { type : 'EmployeeData' , url : 'https://schema.com/...employeedata' , }, req : { monthlySalary : { $gt : 1000 , // monthlySalary must be over $1000 }, }, }, }, }; Schema type yet to be defined","title":"Greater-than"},{"location":"verify-with-zkp-application-level/query-language/#in","text":"Claim UserGameI te ms { \"item\" : \"52\" , // 52 identifies a specific in-game item } Query const proofRequest : protocol.ZKPRequest = { id : 1 , circuit_id : 'credentialAtomicQuerySig' , rules : { query : { allowedIssuers : [ '*' ], schema : { type : 'UserGameItems' , url : 'https://schema.com/...usergameitems' , }, req : { item : { $in : [ 47 , 52 , 112 , 145 ], // accept users that have an item included in the list }, }, }, }, }; Schema type yet to be defined","title":"In"},{"location":"verify-with-zkp-application-level/query-language/#not-in","text":"Claim Cou ntr yO f Reside n ceCrede nt ial { \"countryCode\" : \"840\" } Query const proofRequest : protocol.ZKPRequest = { id : 1 , circuit_id : 'credentialAtomicQuerySig' , rules : { query : { allowedIssuers : [ '11BL1tHEwMR1tuCERfnaYbw4m5QPf45PKfFKZTL2Ep' ], // ID of the trusted issuer schema : { type : 'CountryOfResidenceCredential' , url : 'https://schema.polygonid.com/jsonld/kyc.json-ld' , }, req : { countryCode : { $nin : [ 840 , 120 , 340 , 509 ], // accepted any country not in the list }, }, }, }, }; To add a operator-based query inside a proof request is not mandatory. For instance, a platform can just ask the user to have an AgeCredential claim as a way to identity unique humans without any requirements on the date of birth. In that case the veriifer should simply not fill the req field inside the proofRequest","title":"Not-in"},{"location":"verify-with-zkp-application-level/zk-login-integration/","text":"ZK Login Integration The intergation of this workflow inside your application only requires to embed a button to initiate the login process on the front-end. After this button is pressed, the front-end makes a request to the back-end to generate an auth request and displays it in a QR code. When a user scans the QR code using their wallet, it generates a zk proof and sends this proof packed inside a JWZ to the call-back URL in order to verify it. Overall there are 2 endpoints to be added to the verifier's backend: GET /api/sign-in - should return auth request inside a QR code POST /api/callback - should receive the callback request from the identity wallet containing the proof and verify it The user should have the Polygon ID identity wallet (or any compatible wallet) installed on their device. Integrate with Javascript and GoLang Context: You are a platform that wants to authenticate users according to their age. If they are younger than a certain age, users are not allowed to log-in. The naive web2 way to perform this action would be to make users fill up a form with personal information. In web3 we can perform the same never accessing any user's PII. Add the authorization package to your project GoLang Javascript go get github.com/iden3/go-iden3-auth npm i @iden3/js-iden3-auth --save Set up a server GoLang Javascript package main import ( \"encoding/json\" \"fmt\" \"io\" \"net/http\" \"strconv\" \"time\" \"github.com/iden3/go-circuits\" auth \"github.com/iden3/go-iden3-auth\" \"github.com/iden3/go-iden3-auth/loaders\" \"github.com/iden3/go-iden3-auth/pubsignals\" \"github.com/iden3/go-iden3-auth/state\" \"github.com/iden3/iden3comm/protocol\" ) func main () { http . HandleFunc ( \"/api/sign-in\" , GetQR ) http . HandleFunc ( \"/api/callback\" , Callback ) http . ListenAndServe ( \":8080\" , nil ) } // Create a map to store the auth requests and their session IDs var requestMap = make ( map [ string ] interface {}) const express = require ( 'express' ); const { auth , resolver , loaders } = require ( '@iden3/js-iden3-auth' ) const getRawBody = require ( 'raw-body' ) const app = express (); const port = 8080 ; app . get ( \"/api/sign-in\" , ( req , res ) => { console . log ( 'get QR' ); getQR ( req , res ); }); app . post ( \"/api/callback\" , ( req , res ) => { console . log ( 'callback' ); callback ( req , res ); }); app . listen ( port , () => { console . log ( 'server running on port 8080' ); }); // Create a map to store the auth requests and their session IDs const requestMap = new Map (); Sign-in endpoint This is the endpoint that the user must interact with when trying to log-in into your platform. The most important part here is the definition of the request that gets presented to the user. Understand how to design queries GoLang Javascript // GetQR returns auth request func GetQR ( w http . ResponseWriter , r * http . Request ) { // Audience is verifier id rURL := \"<YOUR REMOTE HOST>\" ; sessionID := 1 CallbackURL := \"/api/callback\" Audience := \"1125GJqgw6YEsKFwj63GY87MMxPL9kwDKxPUiwMLNZ\" uri := fmt . Sprintf ( \"%s%s?sessionId=%s\" , rURL , CallbackURL , strconv . Itoa ( sessionID )) var request protocol . AuthorizationRequestMessage // Generate request for basic authentication request = auth . CreateAuthorizationRequestWithMessage ( \"test flow\" , \"message to sign\" , Audience , uri ) request . ID = \"7f38a193-0918-4a48-9fac-36adfdb8b542\" request . ThreadID = \"7f38a193-0918-4a48-9fac-36adfdb8b542\" // Add request for a specific proof var mtpProofRequest protocol . ZeroKnowledgeProofRequest mtpProofRequest . ID = 1 mtpProofRequest . CircuitID = string ( circuits . AtomicQuerySigCircuitID ) mtpProofRequest . Rules = map [ string ] interface {}{ \"query\" : pubsignals . Query { AllowedIssuers : [] string { \"*\" }, Req : map [ string ] interface {}{ \"birthDay\" : map [ string ] interface {}{ \"$lt\" : 20000101 , }, }, Schema : protocol . Schema { URL : \"https://schema.polygonid.com/jsonld/kyc.json-ld\" , Type : \"AgeCredential\" , }, }, } request . Body . Scope = append ( request . Body . Scope , mtpProofRequest ) // Store auth request in map associated with session ID requestMap [ strconv . Itoa ( sessionID )] = request msgBytes , _ := json . Marshal ( request ) w . Header (). Set ( \"Content-Type\" , \"application/json\" ) w . WriteHeader ( http . StatusOK ) w . Write ( msgBytes ) return } // GetQR returns auth request async function getQR ( req , res ) { // Audience is verifier id const hostUrl = '<YOUR REMOTE HOST>' ; const sessionId = 1 ; const callbackURL = \"/api/callback\" const audience = \"1125GJqgw6YEsKFwj63GY87MMxPL9kwDKxPUiwMLNZ\" const uri = ` ${ hostUrl }${ callbackURL } ?sessionId= ${ sessionId } ` ; // Generate request for basic authentication const request = auth . createAuthorizationRequestWithMessage ( 'test flow' , 'message to sign' , audience , uri , ); request . id = '7f38a193-0918-4a48-9fac-36adfdb8b542' ; request . thid = '7f38a193-0918-4a48-9fac-36adfdb8b542' ; // Add request for a specific proof const proofRequest = { id : 1 , circuit_id : 'credentialAtomicQuerySig' , rules : { query : { allowedIssuers : [ '*' ], schema : { type : 'AgeCredential' , url : 'https://schema.polygonid.com/jsonld/kyc.json-ld' , }, req : { birthDay : { $lt : 20000101 , // bithDay field less then 2000/01/01 }, }, }, }, }; const scope = request . body . scope ?? []; request . body . scope = [... scope , proofRequest ]; // Store auth request in map associated with session ID requestMap . set ( ` ${ sessionId } ` , request ); return res . status ( 200 ). set ( 'Content-Type' , 'application/json' ). send ( request ); } Note the auth request doesn't need to include a query for a specific proof ( mtpProofRequest ). A web application can simply create an authorization request with a message to sign only using the auth.createAuthorizationRequestWithMessage method without appending any Scope to the request body. An even simpler authorization request may also not need any message to sign, in that case you should implement the auth.createAuthorizationRequest authorization method. Callback endpoint The callback post endpoint receives the JWZ from the identity wallet. The role of the callback endpoint is to execute the verification on the proof and further verification based on its input. The verification is executed inside the verifier.FullVerify function To ADD: The identity state contractAddress on polygon mainnet is 0xb8a86e138C3fe64CbCba9731216B1a638EEc55c8. The public verification keys for iden3 circuits generated after the trusted setup can be found here and must be added to your project inside a folder called keys . Also, don't forget to add the RPC endpoint (such as Alchemy or Infura) inside the ethURL variable! GoLang Javascript // Callback verifies the proof after sign-in callbacks func Callback ( w http . ResponseWriter , r * http . Request ) { // Get session ID from request sessionID := r . URL . Query (). Get ( \"sessionId\" ) // get JWZ token params from the post request tokenBytes , err := io . ReadAll ( r . Body ) // Add Polygon RPC node endpoint - needed to read on-chain state ethURL := \"<RPCNODEURL>\" // Add identity state contract address contractAddress := \"0xb8a86e138C3fe64CbCba9731216B1a638EEc55c8\" // Locate the directory that contains circuit's verification keys keyDIR := \"../keys\" // fetch authRequest from sessionID authRequest , _ := requestMap [ sessionID ] // load the verifcation key var verificationKeyloader = & loaders . FSKeyLoader { Dir : keyDIR } resolver := state . ETHResolver { RPCUrl : ethURL , Contract : contractAddress , } // EXECUTE VERIFICATION verifier := auth . NewVerifier ( verificationKeyloader , loaders . DefaultSchemaLoader { IpfsURL : \"ipfs.io\" }, resolver ) authResponse , err := verifier . FullVerify ( r . Context (), string ( tokenBytes ), authRequest .( protocol . AuthorizationRequestMessage )) if err != nil { http . Error ( w , err . Error (), http . StatusInternalServerError ) return } userID := authResponse . From messageBytes := [] byte ( \"User with ID \" + userID + \" Successfully authenticated\" ) w . WriteHeader ( http . StatusOK ) w . Header (). Set ( \"Content-Type\" , \"application/json\" ) w . Write ( messageBytes ) return } // Callback verifies the proof after sign-in callbacks async function callback ( req , res ) { // Get session ID from request const sessionId = req . query . sessionId ; // get JWZ token params from the post request const raw = await getRawBody ( req ); const tokenStr = raw . toString (). trim (); // fetch authRequest from sessionID const authRequest = requestMap . get ( ` ${ sessionId } ` ); // Locate the directory that contains circuit's verification keys const verificationKeyloader = new loaders . FSKeyLoader ( '../keys' ); const sLoader = new loaders . UniversalSchemaLoader ( 'ipfs.io' ); // Add Polygon RPC node endpoint - needed to read on-chain state and identity state contract address const ethStateResolver = new resolver . EthStateResolver ( '<RPCNODEURL>' , '0xb8a86e138C3fe64CbCba9731216B1a638EEc55c8' ); // EXECUTE VERIFICATION const verifier = new auth . Verifier ( verificationKeyloader , sLoader , ethStateResolver , ); try { authResponse = await verifier . fullVerify ( tokenStr , authRequest ); } catch ( error ) { return res . status ( 500 ). send ( error ); } return res . status ( 200 ). set ( 'Content-Type' , 'application/json' ). send ( \"user with ID: \" + authResponse . from + \" Succesfully authenticated\" ); } Verification Procedure The auth library provides a simple handler to extract all the necessary metadata from the JWZ token and execute all the verifications needed. The verification procedure that is happening behind the scenes involves: Zero Knowledge Proof Verification Starting from the circuit specific public verification key, the proof and the public inputs provided by the user inside the JWZ it is possible to verify the proof. In this case the Proof verification involves: Verification of the proof contained in the JWZ signature based on the Auth Circuit Verification of the proof contained in the JWZ payload based on the AtomicQuerySig Circuit or AtomicQueryMTP based on the query. Verification of On-chain Identity States Starting from the Identifier of the user, the State is fetched from blockchain and compared to the state provided as input to the proof to check whether the user is actually \"owner\" of the state used to generate the proof. It's important to note here is that there's no gas cost associated with the verification as the VerifyState method is just reading the identity state of the user on-chain without making any operations/smart contract call. The same verfication is performed for the Issuer Identity State. In this part, it is also verified that the claim hasn't been revoked by the Issuer. Verification of Circuit Public Inputs This involves a verification based on the public inputs of the circuits used to generate the proof. These must match the rules requested by the verifier inside the auth request. For example the query and the claim schema used by the user to generate the proof must match the auth request: The message signed by the user is the same as the one passed to the user in the auth request The rules such as the query or the claim schema used as public input for the circuit match the ones included inside the auth request. This \"off-circuit\" verification is important because a user can potentially modify the query and present a valid proof. A user born the 2000-12-31 shouldn't pass the check. But if they generate a proof using a query input \"$lt\": 20010101 , the verifier would see it as a valid proof. By doing verifying the public inputs of the circuit, the verifier is able to detect the cheat. The executable code for this section can be found here","title":"ZK login integration"},{"location":"verify-with-zkp-application-level/zk-login-integration/#zk-login-integration","text":"The intergation of this workflow inside your application only requires to embed a button to initiate the login process on the front-end. After this button is pressed, the front-end makes a request to the back-end to generate an auth request and displays it in a QR code. When a user scans the QR code using their wallet, it generates a zk proof and sends this proof packed inside a JWZ to the call-back URL in order to verify it. Overall there are 2 endpoints to be added to the verifier's backend: GET /api/sign-in - should return auth request inside a QR code POST /api/callback - should receive the callback request from the identity wallet containing the proof and verify it The user should have the Polygon ID identity wallet (or any compatible wallet) installed on their device.","title":"ZK Login Integration"},{"location":"verify-with-zkp-application-level/zk-login-integration/#integrate-with-javascript-and-golang","text":"Context: You are a platform that wants to authenticate users according to their age. If they are younger than a certain age, users are not allowed to log-in. The naive web2 way to perform this action would be to make users fill up a form with personal information. In web3 we can perform the same never accessing any user's PII. Add the authorization package to your project GoLang Javascript go get github.com/iden3/go-iden3-auth npm i @iden3/js-iden3-auth --save Set up a server GoLang Javascript package main import ( \"encoding/json\" \"fmt\" \"io\" \"net/http\" \"strconv\" \"time\" \"github.com/iden3/go-circuits\" auth \"github.com/iden3/go-iden3-auth\" \"github.com/iden3/go-iden3-auth/loaders\" \"github.com/iden3/go-iden3-auth/pubsignals\" \"github.com/iden3/go-iden3-auth/state\" \"github.com/iden3/iden3comm/protocol\" ) func main () { http . HandleFunc ( \"/api/sign-in\" , GetQR ) http . HandleFunc ( \"/api/callback\" , Callback ) http . ListenAndServe ( \":8080\" , nil ) } // Create a map to store the auth requests and their session IDs var requestMap = make ( map [ string ] interface {}) const express = require ( 'express' ); const { auth , resolver , loaders } = require ( '@iden3/js-iden3-auth' ) const getRawBody = require ( 'raw-body' ) const app = express (); const port = 8080 ; app . get ( \"/api/sign-in\" , ( req , res ) => { console . log ( 'get QR' ); getQR ( req , res ); }); app . post ( \"/api/callback\" , ( req , res ) => { console . log ( 'callback' ); callback ( req , res ); }); app . listen ( port , () => { console . log ( 'server running on port 8080' ); }); // Create a map to store the auth requests and their session IDs const requestMap = new Map (); Sign-in endpoint This is the endpoint that the user must interact with when trying to log-in into your platform. The most important part here is the definition of the request that gets presented to the user. Understand how to design queries GoLang Javascript // GetQR returns auth request func GetQR ( w http . ResponseWriter , r * http . Request ) { // Audience is verifier id rURL := \"<YOUR REMOTE HOST>\" ; sessionID := 1 CallbackURL := \"/api/callback\" Audience := \"1125GJqgw6YEsKFwj63GY87MMxPL9kwDKxPUiwMLNZ\" uri := fmt . Sprintf ( \"%s%s?sessionId=%s\" , rURL , CallbackURL , strconv . Itoa ( sessionID )) var request protocol . AuthorizationRequestMessage // Generate request for basic authentication request = auth . CreateAuthorizationRequestWithMessage ( \"test flow\" , \"message to sign\" , Audience , uri ) request . ID = \"7f38a193-0918-4a48-9fac-36adfdb8b542\" request . ThreadID = \"7f38a193-0918-4a48-9fac-36adfdb8b542\" // Add request for a specific proof var mtpProofRequest protocol . ZeroKnowledgeProofRequest mtpProofRequest . ID = 1 mtpProofRequest . CircuitID = string ( circuits . AtomicQuerySigCircuitID ) mtpProofRequest . Rules = map [ string ] interface {}{ \"query\" : pubsignals . Query { AllowedIssuers : [] string { \"*\" }, Req : map [ string ] interface {}{ \"birthDay\" : map [ string ] interface {}{ \"$lt\" : 20000101 , }, }, Schema : protocol . Schema { URL : \"https://schema.polygonid.com/jsonld/kyc.json-ld\" , Type : \"AgeCredential\" , }, }, } request . Body . Scope = append ( request . Body . Scope , mtpProofRequest ) // Store auth request in map associated with session ID requestMap [ strconv . Itoa ( sessionID )] = request msgBytes , _ := json . Marshal ( request ) w . Header (). Set ( \"Content-Type\" , \"application/json\" ) w . WriteHeader ( http . StatusOK ) w . Write ( msgBytes ) return } // GetQR returns auth request async function getQR ( req , res ) { // Audience is verifier id const hostUrl = '<YOUR REMOTE HOST>' ; const sessionId = 1 ; const callbackURL = \"/api/callback\" const audience = \"1125GJqgw6YEsKFwj63GY87MMxPL9kwDKxPUiwMLNZ\" const uri = ` ${ hostUrl }${ callbackURL } ?sessionId= ${ sessionId } ` ; // Generate request for basic authentication const request = auth . createAuthorizationRequestWithMessage ( 'test flow' , 'message to sign' , audience , uri , ); request . id = '7f38a193-0918-4a48-9fac-36adfdb8b542' ; request . thid = '7f38a193-0918-4a48-9fac-36adfdb8b542' ; // Add request for a specific proof const proofRequest = { id : 1 , circuit_id : 'credentialAtomicQuerySig' , rules : { query : { allowedIssuers : [ '*' ], schema : { type : 'AgeCredential' , url : 'https://schema.polygonid.com/jsonld/kyc.json-ld' , }, req : { birthDay : { $lt : 20000101 , // bithDay field less then 2000/01/01 }, }, }, }, }; const scope = request . body . scope ?? []; request . body . scope = [... scope , proofRequest ]; // Store auth request in map associated with session ID requestMap . set ( ` ${ sessionId } ` , request ); return res . status ( 200 ). set ( 'Content-Type' , 'application/json' ). send ( request ); } Note the auth request doesn't need to include a query for a specific proof ( mtpProofRequest ). A web application can simply create an authorization request with a message to sign only using the auth.createAuthorizationRequestWithMessage method without appending any Scope to the request body. An even simpler authorization request may also not need any message to sign, in that case you should implement the auth.createAuthorizationRequest authorization method. Callback endpoint The callback post endpoint receives the JWZ from the identity wallet. The role of the callback endpoint is to execute the verification on the proof and further verification based on its input. The verification is executed inside the verifier.FullVerify function To ADD: The identity state contractAddress on polygon mainnet is 0xb8a86e138C3fe64CbCba9731216B1a638EEc55c8. The public verification keys for iden3 circuits generated after the trusted setup can be found here and must be added to your project inside a folder called keys . Also, don't forget to add the RPC endpoint (such as Alchemy or Infura) inside the ethURL variable! GoLang Javascript // Callback verifies the proof after sign-in callbacks func Callback ( w http . ResponseWriter , r * http . Request ) { // Get session ID from request sessionID := r . URL . Query (). Get ( \"sessionId\" ) // get JWZ token params from the post request tokenBytes , err := io . ReadAll ( r . Body ) // Add Polygon RPC node endpoint - needed to read on-chain state ethURL := \"<RPCNODEURL>\" // Add identity state contract address contractAddress := \"0xb8a86e138C3fe64CbCba9731216B1a638EEc55c8\" // Locate the directory that contains circuit's verification keys keyDIR := \"../keys\" // fetch authRequest from sessionID authRequest , _ := requestMap [ sessionID ] // load the verifcation key var verificationKeyloader = & loaders . FSKeyLoader { Dir : keyDIR } resolver := state . ETHResolver { RPCUrl : ethURL , Contract : contractAddress , } // EXECUTE VERIFICATION verifier := auth . NewVerifier ( verificationKeyloader , loaders . DefaultSchemaLoader { IpfsURL : \"ipfs.io\" }, resolver ) authResponse , err := verifier . FullVerify ( r . Context (), string ( tokenBytes ), authRequest .( protocol . AuthorizationRequestMessage )) if err != nil { http . Error ( w , err . Error (), http . StatusInternalServerError ) return } userID := authResponse . From messageBytes := [] byte ( \"User with ID \" + userID + \" Successfully authenticated\" ) w . WriteHeader ( http . StatusOK ) w . Header (). Set ( \"Content-Type\" , \"application/json\" ) w . Write ( messageBytes ) return } // Callback verifies the proof after sign-in callbacks async function callback ( req , res ) { // Get session ID from request const sessionId = req . query . sessionId ; // get JWZ token params from the post request const raw = await getRawBody ( req ); const tokenStr = raw . toString (). trim (); // fetch authRequest from sessionID const authRequest = requestMap . get ( ` ${ sessionId } ` ); // Locate the directory that contains circuit's verification keys const verificationKeyloader = new loaders . FSKeyLoader ( '../keys' ); const sLoader = new loaders . UniversalSchemaLoader ( 'ipfs.io' ); // Add Polygon RPC node endpoint - needed to read on-chain state and identity state contract address const ethStateResolver = new resolver . EthStateResolver ( '<RPCNODEURL>' , '0xb8a86e138C3fe64CbCba9731216B1a638EEc55c8' ); // EXECUTE VERIFICATION const verifier = new auth . Verifier ( verificationKeyloader , sLoader , ethStateResolver , ); try { authResponse = await verifier . fullVerify ( tokenStr , authRequest ); } catch ( error ) { return res . status ( 500 ). send ( error ); } return res . status ( 200 ). set ( 'Content-Type' , 'application/json' ). send ( \"user with ID: \" + authResponse . from + \" Succesfully authenticated\" ); }","title":"Integrate with Javascript and GoLang"},{"location":"verify-with-zkp-application-level/zk-login-integration/#verification-procedure","text":"The auth library provides a simple handler to extract all the necessary metadata from the JWZ token and execute all the verifications needed. The verification procedure that is happening behind the scenes involves:","title":"Verification Procedure"},{"location":"verify-with-zkp-application-level/zk-login-integration/#zero-knowledge-proof-verification","text":"Starting from the circuit specific public verification key, the proof and the public inputs provided by the user inside the JWZ it is possible to verify the proof. In this case the Proof verification involves: Verification of the proof contained in the JWZ signature based on the Auth Circuit Verification of the proof contained in the JWZ payload based on the AtomicQuerySig Circuit or AtomicQueryMTP based on the query.","title":"Zero Knowledge Proof Verification"},{"location":"verify-with-zkp-application-level/zk-login-integration/#verification-of-on-chain-identity-states","text":"Starting from the Identifier of the user, the State is fetched from blockchain and compared to the state provided as input to the proof to check whether the user is actually \"owner\" of the state used to generate the proof. It's important to note here is that there's no gas cost associated with the verification as the VerifyState method is just reading the identity state of the user on-chain without making any operations/smart contract call. The same verfication is performed for the Issuer Identity State. In this part, it is also verified that the claim hasn't been revoked by the Issuer.","title":"Verification of On-chain Identity States"},{"location":"verify-with-zkp-application-level/zk-login-integration/#verification-of-circuit-public-inputs","text":"This involves a verification based on the public inputs of the circuits used to generate the proof. These must match the rules requested by the verifier inside the auth request. For example the query and the claim schema used by the user to generate the proof must match the auth request: The message signed by the user is the same as the one passed to the user in the auth request The rules such as the query or the claim schema used as public input for the circuit match the ones included inside the auth request. This \"off-circuit\" verification is important because a user can potentially modify the query and present a valid proof. A user born the 2000-12-31 shouldn't pass the check. But if they generate a proof using a query input \"$lt\": 20010101 , the verifier would see it as a valid proof. By doing verifying the public inputs of the circuit, the verifier is able to detect the cheat. The executable code for this section can be found here","title":"Verification of Circuit Public Inputs"},{"location":"verify-with-zkp-application-level/zk-login-workflow/","text":"ZK Login Workflow Platforms can leverage iden3 to login and authenticate users with Zero Knowledge. Login Workflow A Web application designs an authentication request to users that want to access the website. This is generated by the server and embedded in a QR code (or via deep-linking, it is up to the implementer). The user scans the QR code using their mobile wallet and parse the request The user generates a ZK proof on mobile according to the request of the website The user packs the response into a JWZ (JSON Web Zero Knowledge) and sends it to the callback server The server verifies the ZK proof and, if verified, grants user access to the platform (or sets up any customized logic) Auth request The web application, via its server, presents a request to the user for authentication purpose. The auth request describes the conditions that must be satisfied to authenticate the user. { \"id\" : \"7f38a193-0918-4a48-9fac-36adfdb8b542\" , \"typ\" : \"application/iden3comm-plain-json\" , \"type\" : \"https://iden3-communication.io/authorization/1.0/request\" , \"thid\" : \"7f38a193-0918-4a48-9fac-36adfdb8b542\" , \"body\" :{ \"callbackUrl\" : \"http://localhost:8080/api/callback?sessionId=1\" , \"reason\" : \"test flow\" , \"message\" : \"message to sign\" , \"scope\" :[ { \"id\" : 1 , \"circuit_id\" : \"credentialAtomicQuerySig\" , \"rules\" :{ \"query\" :{ \"allowedIssuers\" :[ \"*\" ], \"req\" :{ \"birthDay\" :{ \"$lt\" : 20000101 }}, \"schema\" :{ \"url\" : \"https://schema.polygonid.com/jsonld/kyc.json-ld\" , \"type\" : \"AgeCredential\" }}}} ] }, \"from\" : \"1125GJqgw6YEsKFwj63GY87MMxPL9kwDKxPUiwMLNZ\" } The body of the Auth Request includes: callbackUrl of the server where to send the response reason describes the goal of the authentication message represents the message to be signed by the user inside the proof generation scope describes the type of proof that the web application requests to the user in order to authenticate Focusing of the scope, it contains: id , uniquely identitfies the request circuit_id , describes the type of circuit that must be used to generate the proof. It can be credentialAtomicQuerySig or credentialAtomicQueryMTP depending on how the claim was issued . rules that must apply by the user when generating the proof such as: query , that includes allowed_issuers , which is an array of IDs of allowed issuers, and a set of requirement req for that specific claim, for example that the value birthday inside user's Claim is less than ( $lt ) 2000/01/01. schema includes the url of the claim JSON schema and type of the claim requested In this case, the verifier is setting the rules for the login. The user must have been born before 2000/01/01 . This is information must exist inside a claim of type AgeCredential that satisfies a specific schema format . The verifier is not setting specific requirement for the allowedIssuers that issued the AgeCredential claim. Lastly, the proof must be generated using credentialAtomicQuerySig circuit. from identifies the subject that is making the request, in this case the web application. The auth request message can be delivered to the user's identity wallet through different communication channels: QR code, email, deep-linking, etc. To design more specific queries Auth response When receiveing the auth request, the identity wallet will: Parse the authorization request and resolve the verifier identifier if required. Generate proof(s) using the handler specified in the request. Pack the proof inside a JWZ (JSON Web Zero Knowledge) and send it to the callback url. JWZ eyJhbGciOiJncm90aDE2IiwiY2lyY3VpdElkIjoiYXV0aCIsImNyaXQiOlsiY2lyY3VpdElkIl0sInR5cCI6ImFwcGxpY2F0aW9uL2lkZW4zLXprcC1qc29uIn0 . eyJpZCI6IjZhOWU4MDlhLTAwNzktNDI2OS1hMzA5LTdlYmIyZDE2YTIzYyIsInR5cCI6ImFwcGxpY2F0aW9uL2lkZW4zY29tbS1wbGFpbi1qc29uIiwidHlwZSI6Imh0dHBzOi8vaWRlbjMtY29tbXVuaWNhdGlvbi5pby9hdXRob3JpemF0aW9uLzEuMC9yZXNwb25zZSIsInRoaWQiOiI3ZjM4YTE5My0wOTE4LTRhNDgtOWZhYy0zNmFkZmRiOGI1NDIiLCJmcm9tIjoiMTFCckE5cmhiWEJwWEMyS0tUOTlzNTEyc1htYnlWa3V1MjFuWWU0NHFiIiwidG8iOiIxMTI1R0pxZ3c2WUVzS0Z3ajYzR1k4N01NeFBMOWt3REt4UFVpd01MTloiLCJib2R5Ijp7Im1lc3NhZ2UiOiJtZXNzYWdlIHRvIHNpZ24iLCJzY29wZSI6W3siaWQiOjEsImNpcmN1aXRfaWQiOiJjcmVkZW50aWFsQXRvbWljUXVlcnlTaWciLCJwcm9vZiI6eyJwaV9hIjpbIjIzNDkzNTkyMTg4NjIyMTAxOTk4NTgzMTc3MTE2OTMwMDAyNTg2MzIwMjQxMzk4MjE2NTQ0MTk1Nzg4MTg3MTc0MDk5MTExMDMzNDUiLCI5NzgzNjU5NTQyNzgxOTM1OTQ3NTk0MjcxMTk1ODA5OTk3MzcyOTM4NDk5NzQ1MDM3NzI1MjMxNDgwNjE3NzgyODk1MTA4Nzk4NjM4IiwiMSJdLCJwaV9iIjpbWyIyNzIyNTc0ODgxMjgxNTQ1MDgyOTAzNjAyMjIyMDYwOTQ3MjA3OTA0NzcwMjYyMzMwOTM2NTQ3MTQ5NjAzNzAxNzE5MTE1Njc2OTY2IiwiOTEyNTA4MDA3ODY0MzM4OTU0ODIzNzExMjk1NDU2MzAyOTE4NTU1NjI4NjMwMTg5MDM5ODc2MzUxNDUyMzExOTQ4MDAzNjU3MDMxMSJdLFsiMTM2NDAzMDk4MDA3ODQwNTUyMDI2OTYwOTk3ODI5MTk3OTg1NjE5ODU0OTA3MDI2NjM1MzgxNjgyMTkxMTUxNzU4NDk5OTk5MTkzNzMiLCIxMDM2MzMyMDQ2MjI5NjAwMTc5ODU2MDUwNTc4MTM5NzM3MzAzMjk0MzI5NzU3MTU4OTY3NzA3NjQyMDU1MDg3Nzg2MzYzNDQ3NzY1MiJdLFsiMSIsIjAiXV0sInBpX2MiOlsiMTk0NjgyODk1MDc0Mjg1MTUyOTcwNTU0MjM1MjEzNjkwNTg1MTQ4NTgyMjgxMTE0MDA2MTkzOTcwODkxODQ3OTg3OTU1MDIwMzA0MzQiLCI2MTg0NTc0NjY3ODYyNjg5OTQ2Mjk0MzgwMDAxMDk5NjgzOTI3NTYwMzk0ODE4MjM2Mzc5MzEzNTgxMTI2NjIwMjYyMDUxMzI1OTkwIiwiMSJdLCJjdXJ2ZSI6bnVsbCwicHJvdG9jb2wiOiJncm90aDE2In0sInB1Yl9zaWduYWxzIjpbIjE2NTE2MTkxMjIyMjc2NDg0NzQzMDE5NDIyMDM5ODIxMTA4ODcwNjI3MjcxNTgwNzIwMzI5NTk5MzQwNzg5MjQxMjcwMDE1Mjg2Mjg4IiwiMzc4MTg4ODY2MjM0Njc5Nzk0MTcxNjY1Njk4NTU0NjQ4OTEyMjYyNTUwMTQzODY2NTUyMzY5MTQ3NDY4MTY2OTAyMzc4NzkwOTEyIiwiMTI5NzU3NjYzNTEzNTMyMjM1ODA4MDk5MDYxNzAwMDY0NjYwNzAzOTQ3NDE3ODM5MjUzOTI2OTE1MTU5NDc2NTI2NDc1MTY3NDYxODIiLCIxIiwiNTMxMDMwMjA4MzM5MTc0NDM5OTUxMDAxNTExODU5MjI4OTU5MTYyMTkzNDcwNzY5NTM2MDMwMzIxODI4MTIyMjI2MDczOTI3NjgiLCIxNTU4NjUxOTcwMDcwNTkxMjc3OTE3MzU3MzgzMDEyMTYyMzU2NTg4OTcyODE3MjAzOTE5NTk2ODQyNTU3MTA5MTAxMzc0NTY5ODg2NiIsIjE2NTUzMDQwNDkiLCIyMTA0NTk1Nzk4NTkwNTgxMzU0MDQ3NzAwNDM3ODgwMjgyOTIzOTgiLCIyIiwiMiIsIjIwMDAwMTAxIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIl19XX19 . eyJwcm9vZiI6eyJwaV9hIjpbIjIxNzkwODAzMjI2NDE1NDQzNTg3NTAzMjk4NzY5MjQwODA5MDYzMTE5MTgzMjY4MzMzODU1NzM4MTI4NDU4MDA2NjI1MTM4NzM4MTIwIiwiMTY2OTg2MjAyMzY2MjE3Mjk1MjM4NjUzNzc5MTkzODMyNjM2MDc3MzQ4OTU0NjQ5MDEwNDY2ODI3Mjc0NDE4NDczODcwNTM0NTIyMjMiLCIxIl0sInBpX2IiOltbIjQ1MzU3NDg4NDc0NTE2MjA3MjcwMzA4NTA5NjgzNDgyODM1MzMyMjE4OTIxNTY0Nzk3ODQ0Nzg1NTA1NzYyOTE5Njc4NzAxNDYzNjkiLCI5NzM4MjczODE4NDA0ODMyNzYzNzk3NzU1NzI5MzY0NDY5MzU5MDMyNTg5Mzc0MjU3MDc3OTg3MzE0ODQwMDc0MjkxNzAwMDQ2NjYzIl0sWyI4MDQyMTUzMDUwOTA0ODE0NzUzNTI0Mjk5OTM2OTczNjg4MDMzNDg0NzU5MDk5MDAwNjE2OTUyNTk3MjQwOTI0MDIwMTYxNTIyOTAzIiwiMTIxODAwMzE1NDk1NzkwMzU5OTI1MTU5NDI5MzQ1MDk3MjgwNzQ0NDYwMzU5MDU2MDkxNzA2MDAxMTE3NDM4MDgxMDM2MzE1MzAxNiJdLFsiMSIsIjAiXV0sInBpX2MiOlsiMTA3OTQ0MzMyNTU0NTc0MDU0NTcxNTA5NjUxMDgyNDI0MTg2NzkyNzEyNjQyOTExNDIwNzkzNTgzODc3OTUwNTA4NzE4MTg0MDU4NjIiLCIyMDk0MjA1NTIxMTA2NDMyNTg2NjU4NjUxMDAwNzU2NjgwMjcyNjg3NjgxNjIzNzEyMTgyODM2MDQ4Mzk0ODc0MTIyMzk5MTkzNTE5OCIsIjEiXSwicHJvdG9jb2wiOiJncm90aDE2In0sInB1Yl9zaWduYWxzIjpbIjE4MDE2NDYyOTI3NzgzNjAwNDgyODIyNjgxNTQ4OTg1MDYxMDk5MzY5MTQ0MjczMzE1OTA1MDU1Mzc4NDUxMjg5NzM1MjY0MTI3NTMyIiwiMTI5NzU3NjYzNTEzNTMyMjM1ODA4MDk5MDYxNzAwMDY0NjYwNzAzOTQ3NDE3ODM5MjUzOTI2OTE1MTU5NDc2NTI2NDc1MTY3NDYxODIiLCIzNzgxODg4NjYyMzQ2Nzk3OTQxNzE2NjU2OTg1NTQ2NDg5MTIyNjI1NTAxNDM4NjY1NTIzNjkxNDc0NjgxNjY5MDIzNzg3OTA5MTIiXX0 The JWZ, similarly similarly to JWT, contains a header , a payload and a signature . The payload contains the ZK proof based on the query presented inside the Auth Request. The signature is a special Zero Knowledge signature. It contains a proof of identity ownership generated using the authentication circuit To understand how a JWZ looks like Verification The server, after receiveing the JWZ from the identity wallet, performs the verification process. It involves: Zero-knowledge Proof Verification Extraction of Metadata from the JWZ, like the public inputs of the circuit and elements included inside the scope Verification of identity states stored on-chain Verification that the public inputs used to generate the proof matches the rules included inside the auth request. For example the query established by the verifier inside the auth request must match the query used as public input to generate the proof At the end of the workflow: The web-client is able to authenticate the user using its identifier ID after having established that the user controls that identity and satisfies the query presented in the auth request. The user is able to log-in to the platform without disclosing any personal information to the client exept for its identifier","title":"ZK login workflow"},{"location":"verify-with-zkp-application-level/zk-login-workflow/#zk-login-workflow","text":"Platforms can leverage iden3 to login and authenticate users with Zero Knowledge. Login Workflow A Web application designs an authentication request to users that want to access the website. This is generated by the server and embedded in a QR code (or via deep-linking, it is up to the implementer). The user scans the QR code using their mobile wallet and parse the request The user generates a ZK proof on mobile according to the request of the website The user packs the response into a JWZ (JSON Web Zero Knowledge) and sends it to the callback server The server verifies the ZK proof and, if verified, grants user access to the platform (or sets up any customized logic)","title":"ZK Login Workflow"},{"location":"verify-with-zkp-application-level/zk-login-workflow/#auth-request","text":"The web application, via its server, presents a request to the user for authentication purpose. The auth request describes the conditions that must be satisfied to authenticate the user. { \"id\" : \"7f38a193-0918-4a48-9fac-36adfdb8b542\" , \"typ\" : \"application/iden3comm-plain-json\" , \"type\" : \"https://iden3-communication.io/authorization/1.0/request\" , \"thid\" : \"7f38a193-0918-4a48-9fac-36adfdb8b542\" , \"body\" :{ \"callbackUrl\" : \"http://localhost:8080/api/callback?sessionId=1\" , \"reason\" : \"test flow\" , \"message\" : \"message to sign\" , \"scope\" :[ { \"id\" : 1 , \"circuit_id\" : \"credentialAtomicQuerySig\" , \"rules\" :{ \"query\" :{ \"allowedIssuers\" :[ \"*\" ], \"req\" :{ \"birthDay\" :{ \"$lt\" : 20000101 }}, \"schema\" :{ \"url\" : \"https://schema.polygonid.com/jsonld/kyc.json-ld\" , \"type\" : \"AgeCredential\" }}}} ] }, \"from\" : \"1125GJqgw6YEsKFwj63GY87MMxPL9kwDKxPUiwMLNZ\" } The body of the Auth Request includes: callbackUrl of the server where to send the response reason describes the goal of the authentication message represents the message to be signed by the user inside the proof generation scope describes the type of proof that the web application requests to the user in order to authenticate Focusing of the scope, it contains: id , uniquely identitfies the request circuit_id , describes the type of circuit that must be used to generate the proof. It can be credentialAtomicQuerySig or credentialAtomicQueryMTP depending on how the claim was issued . rules that must apply by the user when generating the proof such as: query , that includes allowed_issuers , which is an array of IDs of allowed issuers, and a set of requirement req for that specific claim, for example that the value birthday inside user's Claim is less than ( $lt ) 2000/01/01. schema includes the url of the claim JSON schema and type of the claim requested In this case, the verifier is setting the rules for the login. The user must have been born before 2000/01/01 . This is information must exist inside a claim of type AgeCredential that satisfies a specific schema format . The verifier is not setting specific requirement for the allowedIssuers that issued the AgeCredential claim. Lastly, the proof must be generated using credentialAtomicQuerySig circuit. from identifies the subject that is making the request, in this case the web application. The auth request message can be delivered to the user's identity wallet through different communication channels: QR code, email, deep-linking, etc. To design more specific queries","title":"Auth request"},{"location":"verify-with-zkp-application-level/zk-login-workflow/#auth-response","text":"When receiveing the auth request, the identity wallet will: Parse the authorization request and resolve the verifier identifier if required. Generate proof(s) using the handler specified in the request. Pack the proof inside a JWZ (JSON Web Zero Knowledge) and send it to the callback url.","title":"Auth response"},{"location":"verify-with-zkp-application-level/zk-login-workflow/#jwz","text":"eyJhbGciOiJncm90aDE2IiwiY2lyY3VpdElkIjoiYXV0aCIsImNyaXQiOlsiY2lyY3VpdElkIl0sInR5cCI6ImFwcGxpY2F0aW9uL2lkZW4zLXprcC1qc29uIn0 . eyJpZCI6IjZhOWU4MDlhLTAwNzktNDI2OS1hMzA5LTdlYmIyZDE2YTIzYyIsInR5cCI6ImFwcGxpY2F0aW9uL2lkZW4zY29tbS1wbGFpbi1qc29uIiwidHlwZSI6Imh0dHBzOi8vaWRlbjMtY29tbXVuaWNhdGlvbi5pby9hdXRob3JpemF0aW9uLzEuMC9yZXNwb25zZSIsInRoaWQiOiI3ZjM4YTE5My0wOTE4LTRhNDgtOWZhYy0zNmFkZmRiOGI1NDIiLCJmcm9tIjoiMTFCckE5cmhiWEJwWEMyS0tUOTlzNTEyc1htYnlWa3V1MjFuWWU0NHFiIiwidG8iOiIxMTI1R0pxZ3c2WUVzS0Z3ajYzR1k4N01NeFBMOWt3REt4UFVpd01MTloiLCJib2R5Ijp7Im1lc3NhZ2UiOiJtZXNzYWdlIHRvIHNpZ24iLCJzY29wZSI6W3siaWQiOjEsImNpcmN1aXRfaWQiOiJjcmVkZW50aWFsQXRvbWljUXVlcnlTaWciLCJwcm9vZiI6eyJwaV9hIjpbIjIzNDkzNTkyMTg4NjIyMTAxOTk4NTgzMTc3MTE2OTMwMDAyNTg2MzIwMjQxMzk4MjE2NTQ0MTk1Nzg4MTg3MTc0MDk5MTExMDMzNDUiLCI5NzgzNjU5NTQyNzgxOTM1OTQ3NTk0MjcxMTk1ODA5OTk3MzcyOTM4NDk5NzQ1MDM3NzI1MjMxNDgwNjE3NzgyODk1MTA4Nzk4NjM4IiwiMSJdLCJwaV9iIjpbWyIyNzIyNTc0ODgxMjgxNTQ1MDgyOTAzNjAyMjIyMDYwOTQ3MjA3OTA0NzcwMjYyMzMwOTM2NTQ3MTQ5NjAzNzAxNzE5MTE1Njc2OTY2IiwiOTEyNTA4MDA3ODY0MzM4OTU0ODIzNzExMjk1NDU2MzAyOTE4NTU1NjI4NjMwMTg5MDM5ODc2MzUxNDUyMzExOTQ4MDAzNjU3MDMxMSJdLFsiMTM2NDAzMDk4MDA3ODQwNTUyMDI2OTYwOTk3ODI5MTk3OTg1NjE5ODU0OTA3MDI2NjM1MzgxNjgyMTkxMTUxNzU4NDk5OTk5MTkzNzMiLCIxMDM2MzMyMDQ2MjI5NjAwMTc5ODU2MDUwNTc4MTM5NzM3MzAzMjk0MzI5NzU3MTU4OTY3NzA3NjQyMDU1MDg3Nzg2MzYzNDQ3NzY1MiJdLFsiMSIsIjAiXV0sInBpX2MiOlsiMTk0NjgyODk1MDc0Mjg1MTUyOTcwNTU0MjM1MjEzNjkwNTg1MTQ4NTgyMjgxMTE0MDA2MTkzOTcwODkxODQ3OTg3OTU1MDIwMzA0MzQiLCI2MTg0NTc0NjY3ODYyNjg5OTQ2Mjk0MzgwMDAxMDk5NjgzOTI3NTYwMzk0ODE4MjM2Mzc5MzEzNTgxMTI2NjIwMjYyMDUxMzI1OTkwIiwiMSJdLCJjdXJ2ZSI6bnVsbCwicHJvdG9jb2wiOiJncm90aDE2In0sInB1Yl9zaWduYWxzIjpbIjE2NTE2MTkxMjIyMjc2NDg0NzQzMDE5NDIyMDM5ODIxMTA4ODcwNjI3MjcxNTgwNzIwMzI5NTk5MzQwNzg5MjQxMjcwMDE1Mjg2Mjg4IiwiMzc4MTg4ODY2MjM0Njc5Nzk0MTcxNjY1Njk4NTU0NjQ4OTEyMjYyNTUwMTQzODY2NTUyMzY5MTQ3NDY4MTY2OTAyMzc4NzkwOTEyIiwiMTI5NzU3NjYzNTEzNTMyMjM1ODA4MDk5MDYxNzAwMDY0NjYwNzAzOTQ3NDE3ODM5MjUzOTI2OTE1MTU5NDc2NTI2NDc1MTY3NDYxODIiLCIxIiwiNTMxMDMwMjA4MzM5MTc0NDM5OTUxMDAxNTExODU5MjI4OTU5MTYyMTkzNDcwNzY5NTM2MDMwMzIxODI4MTIyMjI2MDczOTI3NjgiLCIxNTU4NjUxOTcwMDcwNTkxMjc3OTE3MzU3MzgzMDEyMTYyMzU2NTg4OTcyODE3MjAzOTE5NTk2ODQyNTU3MTA5MTAxMzc0NTY5ODg2NiIsIjE2NTUzMDQwNDkiLCIyMTA0NTk1Nzk4NTkwNTgxMzU0MDQ3NzAwNDM3ODgwMjgyOTIzOTgiLCIyIiwiMiIsIjIwMDAwMTAxIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIl19XX19 . eyJwcm9vZiI6eyJwaV9hIjpbIjIxNzkwODAzMjI2NDE1NDQzNTg3NTAzMjk4NzY5MjQwODA5MDYzMTE5MTgzMjY4MzMzODU1NzM4MTI4NDU4MDA2NjI1MTM4NzM4MTIwIiwiMTY2OTg2MjAyMzY2MjE3Mjk1MjM4NjUzNzc5MTkzODMyNjM2MDc3MzQ4OTU0NjQ5MDEwNDY2ODI3Mjc0NDE4NDczODcwNTM0NTIyMjMiLCIxIl0sInBpX2IiOltbIjQ1MzU3NDg4NDc0NTE2MjA3MjcwMzA4NTA5NjgzNDgyODM1MzMyMjE4OTIxNTY0Nzk3ODQ0Nzg1NTA1NzYyOTE5Njc4NzAxNDYzNjkiLCI5NzM4MjczODE4NDA0ODMyNzYzNzk3NzU1NzI5MzY0NDY5MzU5MDMyNTg5Mzc0MjU3MDc3OTg3MzE0ODQwMDc0MjkxNzAwMDQ2NjYzIl0sWyI4MDQyMTUzMDUwOTA0ODE0NzUzNTI0Mjk5OTM2OTczNjg4MDMzNDg0NzU5MDk5MDAwNjE2OTUyNTk3MjQwOTI0MDIwMTYxNTIyOTAzIiwiMTIxODAwMzE1NDk1NzkwMzU5OTI1MTU5NDI5MzQ1MDk3MjgwNzQ0NDYwMzU5MDU2MDkxNzA2MDAxMTE3NDM4MDgxMDM2MzE1MzAxNiJdLFsiMSIsIjAiXV0sInBpX2MiOlsiMTA3OTQ0MzMyNTU0NTc0MDU0NTcxNTA5NjUxMDgyNDI0MTg2NzkyNzEyNjQyOTExNDIwNzkzNTgzODc3OTUwNTA4NzE4MTg0MDU4NjIiLCIyMDk0MjA1NTIxMTA2NDMyNTg2NjU4NjUxMDAwNzU2NjgwMjcyNjg3NjgxNjIzNzEyMTgyODM2MDQ4Mzk0ODc0MTIyMzk5MTkzNTE5OCIsIjEiXSwicHJvdG9jb2wiOiJncm90aDE2In0sInB1Yl9zaWduYWxzIjpbIjE4MDE2NDYyOTI3NzgzNjAwNDgyODIyNjgxNTQ4OTg1MDYxMDk5MzY5MTQ0MjczMzE1OTA1MDU1Mzc4NDUxMjg5NzM1MjY0MTI3NTMyIiwiMTI5NzU3NjYzNTEzNTMyMjM1ODA4MDk5MDYxNzAwMDY0NjYwNzAzOTQ3NDE3ODM5MjUzOTI2OTE1MTU5NDc2NTI2NDc1MTY3NDYxODIiLCIzNzgxODg4NjYyMzQ2Nzk3OTQxNzE2NjU2OTg1NTQ2NDg5MTIyNjI1NTAxNDM4NjY1NTIzNjkxNDc0NjgxNjY5MDIzNzg3OTA5MTIiXX0 The JWZ, similarly similarly to JWT, contains a header , a payload and a signature . The payload contains the ZK proof based on the query presented inside the Auth Request. The signature is a special Zero Knowledge signature. It contains a proof of identity ownership generated using the authentication circuit To understand how a JWZ looks like","title":"JWZ"},{"location":"verify-with-zkp-application-level/zk-login-workflow/#verification","text":"The server, after receiveing the JWZ from the identity wallet, performs the verification process. It involves: Zero-knowledge Proof Verification Extraction of Metadata from the JWZ, like the public inputs of the circuit and elements included inside the scope Verification of identity states stored on-chain Verification that the public inputs used to generate the proof matches the rules included inside the auth request. For example the query established by the verifier inside the auth request must match the query used as public input to generate the proof At the end of the workflow: The web-client is able to authenticate the user using its identifier ID after having established that the user controls that identity and satisfies the query presented in the auth request. The user is able to log-in to the platform without disclosing any personal information to the client exept for its identifier","title":"Verification"}]}